var pptx2html = (function () {
'use strict';

var _isObject = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

var _anObject = function (it) {
  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

var _fails = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

// Thank's IE8 for his funny defineProperty
var _descriptors = !_fails(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _global = createCommonjsModule(function (module) {
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
});

var document$1 = _global.document;
// typeof document.createElement is 'object' in old IE
var is = _isObject(document$1) && _isObject(document$1.createElement);
var _domCreate = function (it) {
  return is ? document$1.createElement(it) : {};
};

var _ie8DomDefine = !_descriptors && !_fails(function () {
  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
});

// 7.1.1 ToPrimitive(input [, PreferredType])

// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
var _toPrimitive = function (it, S) {
  if (!_isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var dP = Object.defineProperty;

var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  _anObject(O);
  P = _toPrimitive(P, true);
  _anObject(Attributes);
  if (_ie8DomDefine) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var _objectDp = {
	f: f
};

var _propertyDesc = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var _hide = _descriptors ? function (object, key, value) {
  return _objectDp.f(object, key, _propertyDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var hasOwnProperty = {}.hasOwnProperty;
var _has = function (it, key) {
  return hasOwnProperty.call(it, key);
};

var id = 0;
var px = Math.random();
var _uid = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

var _core = createCommonjsModule(function (module) {
var core = module.exports = { version: '2.5.1' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
});

var _redefine = createCommonjsModule(function (module) {
var SRC = _uid('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

_core.inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) _has(val, 'name') || _hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === _global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    _hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    _hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});
});

// 7.2.1 RequireObjectCoercible(argument)
var _defined = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

var SHARED = '__core-js_shared__';
var store = _global[SHARED] || (_global[SHARED] = {});
var _shared = function (key) {
  return store[key] || (store[key] = {});
};

var _wks = createCommonjsModule(function (module) {
var store = _shared('wks');

var Symbol = _global.Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
};

$exports.store = store;
});

'use strict';






var _fixReWks = function (KEY, length, exec) {
  var SYMBOL = _wks(KEY);
  var fns = exec(_defined, SYMBOL, ''[KEY]);
  var strfn = fns[0];
  var rxfn = fns[1];
  if (_fails(function () {
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  })) {
    _redefine(String.prototype, KEY, strfn);
    _hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};

// @@replace logic
_fixReWks('replace', 2, function (defined, REPLACE, $replace) {
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue) {
    'use strict';
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});

var toString = {}.toString;

var _cof = function (it) {
  return toString.call(it).slice(8, -1);
};

// 7.2.8 IsRegExp(argument)


var MATCH = _wks('match');
var _isRegexp = function (it) {
  var isRegExp;
  return _isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : _cof(it) == 'RegExp');
};

// @@split logic
_fixReWks('split', 2, function (defined, SPLIT, $split) {
  'use strict';
  var isRegExp = _isRegexp;
  var _split = $split;
  var $push = [].push;
  var $SPLIT = 'split';
  var LENGTH = 'length';
  var LAST_INDEX = 'lastIndex';
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while (match = separatorCopy.exec(string)) {
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          // eslint-disable-next-line no-loop-func
          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
          });
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    $split = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit) {
    var O = defined(this);
    var fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});

var _aFunction = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

// optional / simple context binding

var _ctx = function (fn, that, length) {
  _aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
    // extend global
    if (target) _redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) _hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
_global.core = _core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
var _export = $export;

// fallback for non-array-like ES3 and non-enumerable old V8 strings

// eslint-disable-next-line no-prototype-builtins
var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return _cof(it) == 'String' ? it.split('') : Object(it);
};

// 7.1.13 ToObject(argument)

var _toObject = function (it) {
  return Object(_defined(it));
};

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
var _toInteger = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

// 7.1.15 ToLength

var min = Math.min;
var _toLength = function (it) {
  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

// 7.2.2 IsArray(argument)

var _isArray = Array.isArray || function isArray(arg) {
  return _cof(arg) == 'Array';
};

var SPECIES = _wks('species');

var _arraySpeciesConstructor = function (original) {
  var C;
  if (_isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || _isArray(C.prototype))) C = undefined;
    if (_isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)


var _arraySpeciesCreate = function (original, length) {
  return new (_arraySpeciesConstructor(original))(length);
};

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex





var _arrayMethods = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || _arraySpeciesCreate;
  return function ($this, callbackfn, that) {
    var O = _toObject($this);
    var self = _iobject(O);
    var f = _ctx(callbackfn, that, 3);
    var length = _toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = _wks('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) _hide(ArrayProto, UNSCOPABLES, {});
var _addToUnscopables = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

var $find = _arrayMethods(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
_export(_export.P + _export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
_addToUnscopables(KEY);

// call something on iterator step with safe closing on error

var _iterCall = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(_anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) _anObject(ret.call(iterator));
    throw e;
  }
};

var _iterators = {};

// check on default Array iterator

var ITERATOR = _wks('iterator');
var ArrayProto$1 = Array.prototype;

var _isArrayIter = function (it) {
  return it !== undefined && (_iterators.Array === it || ArrayProto$1[ITERATOR] === it);
};

'use strict';



var _createProperty = function (object, index, value) {
  if (index in object) _objectDp.f(object, index, _propertyDesc(0, value));
  else object[index] = value;
};

// getting tag from 19.1.3.6 Object.prototype.toString()

var TAG = _wks('toStringTag');
// ES3 wrong here
var ARG = _cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

var _classof = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? _cof(O)
    // ES3 arguments fallback
    : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

var ITERATOR$1 = _wks('iterator');

var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR$1]
    || it['@@iterator']
    || _iterators[_classof(it)];
};

var ITERATOR$2 = _wks('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR$2]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  
} catch (e) { /* empty */ }

var _iterDetect = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR$2]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR$2] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

'use strict';









_export(_export.S + _export.F * !_iterDetect(function (iter) {  }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = _toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = core_getIteratorMethod(O);
    var length, result, step, iterator;
    if (mapping) mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && _isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = _toLength(O.length);
      for (result = new C(length); length > index; index++) {
        _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

var _library = false;

var _anInstance = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

var _forOf = createCommonjsModule(function (module) {
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : core_getIteratorMethod(iterable);
  var f = _ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {
    result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = _iterCall(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;
});

// 7.3.20 SpeciesConstructor(O, defaultConstructor)


var SPECIES$1 = _wks('species');
var _speciesConstructor = function (O, D) {
  var C = _anObject(O).constructor;
  var S;
  return C === undefined || (S = _anObject(C)[SPECIES$1]) == undefined ? D : _aFunction(S);
};

// fast apply, http://jsperf.lnkit.com/fast-apply/5
var _invoke = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

var document$2 = _global.document;
var _html = document$2 && document$2.documentElement;

var process$1 = _global.process;
var setTask = _global.setImmediate;
var clearTask = _global.clearImmediate;
var MessageChannel = _global.MessageChannel;
var Dispatch = _global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer;
var channel;
var port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      _invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (_cof(process$1) == 'process') {
    defer = function (id) {
      process$1.nextTick(_ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(_ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = _ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (_global.addEventListener && typeof postMessage == 'function' && !_global.importScripts) {
    defer = function (id) {
      _global.postMessage(id + '', '*');
    };
    _global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in _domCreate('script')) {
    defer = function (id) {
      _html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE] = function () {
        _html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(_ctx(run, id, 1), 0);
    };
  }
}
var _task = {
  set: setTask,
  clear: clearTask
};

var macrotask = _task.set;
var Observer = _global.MutationObserver || _global.WebKitMutationObserver;
var process$2 = _global.process;
var Promise$1 = _global.Promise;
var isNode$1 = _cof(process$2) == 'process';

var _microtask = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode$1 && (parent = process$2.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode$1) {
    notify = function () {
      process$2.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if (Observer) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise$1 && Promise$1.resolve) {
    var promise = Promise$1.resolve();
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(_global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

'use strict';
// 25.4.1.5 NewPromiseCapability(C)


function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = _aFunction(resolve);
  this.reject = _aFunction(reject);
}

var f$1 = function (C) {
  return new PromiseCapability(C);
};

var _newPromiseCapability = {
	f: f$1
};

var _perform = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

var _promiseResolve = function (C, x) {
  _anObject(C);
  if (_isObject(x) && x.constructor === C) return x;
  var promiseCapability = _newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

var _redefineAll = function (target, src, safe) {
  for (var key in src) _redefine(target, key, src[key], safe);
  return target;
};

var def = _objectDp.f;

var TAG$1 = _wks('toStringTag');

var _setToStringTag = function (it, tag, stat) {
  if (it && !_has(it = stat ? it : it.prototype, TAG$1)) def(it, TAG$1, { configurable: true, value: tag });
};

'use strict';



var SPECIES$2 = _wks('species');

var _setSpecies = function (KEY) {
  var C = _global[KEY];
  if (_descriptors && C && !C[SPECIES$2]) _objectDp.f(C, SPECIES$2, {
    configurable: true,
    get: function () { return this; }
  });
};

'use strict';










var task = _task.set;
var microtask = _microtask();



var PROMISE = 'Promise';
var TypeError$1 = _global.TypeError;
var process = _global.process;
var $Promise = _global[PROMISE];
var isNode = _classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal;
var newGenericPromiseCapability;
var OwnPromiseCapability;
var Wrapper;
var newPromiseCapability = newGenericPromiseCapability = _newPromiseCapability.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[_wks('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return _isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }
          if (result === reaction.promise) {
            reject(TypeError$1('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(_global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = _perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = _global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = _global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  if (promise._h == 1) return false;
  var chain = promise._a || promise._c;
  var i = 0;
  var reaction;
  while (chain.length > i) {
    reaction = chain[i++];
    if (reaction.fail || !isUnhandled(reaction.promise)) return false;
  } return true;
};
var onHandleUnhandled = function (promise) {
  task.call(_global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = _global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError$1("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    _anInstance(this, $Promise, PROMISE, '_h');
    _aFunction(executor);
    Internal.call(this);
    try {
      executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = _redefineAll($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(_speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = _ctx($resolve, promise, 1);
    this.reject = _ctx($reject, promise, 1);
  };
  _newPromiseCapability.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

_export(_export.G + _export.W + _export.F * !USE_NATIVE, { Promise: $Promise });
_setToStringTag($Promise, PROMISE);
_setSpecies(PROMISE);
Wrapper = _core[PROMISE];

// statics
_export(_export.S + _export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
_export(_export.S + _export.F * (_library || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return _promiseResolve(_library && this === Wrapper ? $Promise : this, x);
  }
});
_export(_export.S + _export.F * !(USE_NATIVE && _iterDetect(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = _perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      _forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = _perform(function () {
      _forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

var TYPED = _uid('typed_array');
var VIEW = _uid('view');
var ABV = !!(_global.ArrayBuffer && _global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = _global[TypedArrayConstructors[i++]]) {
    _hide(Typed.prototype, TYPED, true);
    _hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

var _typed = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

// https://tc39.github.io/ecma262/#sec-toindex


var _toIndex = function (it) {
  if (it === undefined) return 0;
  var number = _toInteger(it);
  var length = _toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

// to indexed object, toObject with fallback for non-array-like ES3 strings


var _toIobject = function (it) {
  return _iobject(_defined(it));
};

var max = Math.max;
var min$1 = Math.min;
var _toAbsoluteIndex = function (index, length) {
  index = _toInteger(index);
  return index < 0 ? max(index + length, 0) : min$1(index, length);
};

// false -> Array#indexOf
// true  -> Array#includes



var _arrayIncludes = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = _toIobject($this);
    var length = _toLength(O.length);
    var index = _toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

var shared$1 = _shared('keys');

var _sharedKey = function (key) {
  return shared$1[key] || (shared$1[key] = _uid(key));
};

var arrayIndexOf = _arrayIncludes(false);
var IE_PROTO = _sharedKey('IE_PROTO');

var _objectKeysInternal = function (object, names) {
  var O = _toIobject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (_has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

// IE 8- don't enum bug keys
var _enumBugKeys = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)

var hiddenKeys = _enumBugKeys.concat('length', 'prototype');

var f$2 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return _objectKeysInternal(O, hiddenKeys);
};

var _objectGopn = {
	f: f$2
};

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';



var _arrayFill = function fill(value /* , start = 0, end = @length */) {
  var O = _toObject(this);
  var length = _toLength(O.length);
  var aLen = arguments.length;
  var index = _toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : _toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

var _typedBuffer = createCommonjsModule(function (module, exports) {
'use strict';











var gOPN = _objectGopn.f;
var dP = _objectDp.f;


var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = _global[ARRAY_BUFFER];
var $DataView = _global[DATA_VIEW];
var Math = _global.Math;
var RangeError = _global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = _global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = _descriptors ? '_b' : BUFFER;
var $LENGTH = _descriptors ? '_l' : BYTE_LENGTH;
var $OFFSET = _descriptors ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = _toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = _toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!_typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    _anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = _toIndex(length);
    this._b = _arrayFill.call(Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    _anInstance(this, $DataView, DATA_VIEW);
    _anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = _toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : _toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (_descriptors) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  _redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!_fails(function () {
    $ArrayBuffer(1);
  }) || !_fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || _fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      _anInstance(this, $ArrayBuffer);
      return new BaseBuffer(_toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) _hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!_library) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) _redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
_setToStringTag($ArrayBuffer, ARRAY_BUFFER);
_setToStringTag($DataView, DATA_VIEW);
_hide($DataView[PROTOTYPE], _typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;
});

_export(_export.G + _export.W + _export.F * !_typed.ABV, {
  DataView: _typedBuffer.DataView
});

var dP$1 = _objectDp.f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || _descriptors && dP$1(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

var f$4 = {}.propertyIsEnumerable;

var _objectPie = {
	f: f$4
};

var gOPD = Object.getOwnPropertyDescriptor;

var f$3 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = _toIobject(O);
  P = _toPrimitive(P, true);
  if (_ie8DomDefine) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
};

var _objectGopd = {
	f: f$3
};

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */


var check = function (O, proto) {
  _anObject(O);
  if (!_isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
var _setProto = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

// 19.1.3.19 Object.setPrototypeOf(O, proto)

_export(_export.S, 'Object', { setPrototypeOf: _setProto.set });

var _meta = createCommonjsModule(function (module) {
var META = _uid('meta');


var setDesc = _objectDp.f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !_fails(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!_isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!_has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!_has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !_has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};
});

var f$5 = _wks;

var _wksExt = {
	f: f$5
};

var defineProperty = _objectDp.f;
var _wksDefine = function (name) {
  var $Symbol = _core.Symbol || (_core.Symbol = _library ? {} : _global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: _wksExt.f(name) });
};

// 19.1.2.14 / 15.2.3.14 Object.keys(O)



var _objectKeys = Object.keys || function keys(O) {
  return _objectKeysInternal(O, _enumBugKeys);
};

var f$6 = Object.getOwnPropertySymbols;

var _objectGops = {
	f: f$6
};

// all enumerable object keys, includes symbols



var _enumKeys = function (it) {
  var result = _objectKeys(it);
  var getSymbols = _objectGops.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = _objectPie.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
  _anObject(O);
  var keys = _objectKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) _objectDp.f(O, P = keys[i++], Properties[P]);
  return O;
};

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])



var IE_PROTO$1 = _sharedKey('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE$2 = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = _domCreate('iframe');
  var i = _enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  _html.appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE$2][_enumBugKeys[i]];
  return createDict();
};

var _objectCreate = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE$2] = _anObject(O);
    result = new Empty();
    Empty[PROTOTYPE$2] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO$1] = O;
  } else result = createDict();
  return Properties === undefined ? result : _objectDps(result, Properties);
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window

var gOPN$1 = _objectGopn.f;
var toString$1 = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN$1(it);
  } catch (e) {
    return windowNames.slice();
  }
};

var f$7 = function getOwnPropertyNames(it) {
  return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : gOPN$1(_toIobject(it));
};

var _objectGopnExt = {
	f: f$7
};

'use strict';
// ECMAScript 6 symbols shim





var META = _meta.KEY;


















var gOPD$1 = _objectGopd.f;
var dP$2 = _objectDp.f;
var gOPN = _objectGopnExt.f;
var $Symbol = _global.Symbol;
var $JSON = _global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE$1 = 'prototype';
var HIDDEN = _wks('_hidden');
var TO_PRIMITIVE = _wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = _shared('symbol-registry');
var AllSymbols = _shared('symbols');
var OPSymbols = _shared('op-symbols');
var ObjectProto = Object[PROTOTYPE$1];
var USE_NATIVE$1 = typeof $Symbol == 'function';
var QObject = _global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = _descriptors && _fails(function () {
  return _objectCreate(dP$2({}, 'a', {
    get: function () { return dP$2(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD$1(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP$2(it, key, D);
  if (protoDesc && it !== ObjectProto) dP$2(ObjectProto, key, protoDesc);
} : dP$2;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _objectCreate($Symbol[PROTOTYPE$1]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE$1 && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  _anObject(it);
  key = _toPrimitive(key, true);
  _anObject(D);
  if (_has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!_has(it, HIDDEN)) dP$2(it, HIDDEN, _propertyDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (_has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _objectCreate(D, { enumerable: _propertyDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP$2(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  _anObject(it);
  var keys = _enumKeys(P = _toIobject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create$$1(it, P) {
  return P === undefined ? _objectCreate(it) : $defineProperties(_objectCreate(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = _toPrimitive(key, true));
  if (this === ObjectProto && _has(AllSymbols, key) && !_has(OPSymbols, key)) return false;
  return E || !_has(this, key) || !_has(AllSymbols, key) || _has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = _toIobject(it);
  key = _toPrimitive(key, true);
  if (it === ObjectProto && _has(AllSymbols, key) && !_has(OPSymbols, key)) return;
  var D = gOPD$1(it, key);
  if (D && _has(AllSymbols, key) && !(_has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(_toIobject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!_has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : _toIobject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (_has(AllSymbols, key = names[i++]) && (IS_OP ? _has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE$1) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = _uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (_has(this, HIDDEN) && _has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, _propertyDesc(1, value));
    };
    if (_descriptors && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  _redefine($Symbol[PROTOTYPE$1], 'toString', function toString() {
    return this._k;
  });

  _objectGopd.f = $getOwnPropertyDescriptor;
  _objectDp.f = $defineProperty;
  _objectGopn.f = _objectGopnExt.f = $getOwnPropertyNames;
  _objectPie.f = $propertyIsEnumerable;
  _objectGops.f = $getOwnPropertySymbols;

  if (_descriptors && !_library) {
    _redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  _wksExt.f = function (name) {
    return wrap(_wks(name));
  };
}

_export(_export.G + _export.W + _export.F * !USE_NATIVE$1, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)_wks(es6Symbols[j++]);

for (var wellKnownSymbols = _objectKeys(_wks.store), k = 0; wellKnownSymbols.length > k;) _wksDefine(wellKnownSymbols[k++]);

_export(_export.S + _export.F * !USE_NATIVE$1, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return _has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

_export(_export.S + _export.F * !USE_NATIVE$1, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && _export(_export.S + _export.F * (!USE_NATIVE$1 || _fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    replacer = args[1];
    if (typeof replacer == 'function') $replacer = replacer;
    if ($replacer || !_isArray(replacer)) replacer = function (key, value) {
      if ($replacer) value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE$1][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE$1], TO_PRIMITIVE, $Symbol[PROTOTYPE$1].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
_setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
_setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
_setToStringTag(_global.JSON, 'JSON', true);

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _AwaitValue(value) {
  this.wrapped = value;
}

function _AsyncGenerator(gen) {
  var front, back;

  function send(key, arg) {
    return new Promise(function (resolve, reject) {
      var request = {
        key: key,
        arg: arg,
        resolve: resolve,
        reject: reject,
        next: null
      };

      if (back) {
        back = back.next = request;
      } else {
        front = back = request;
        resume(key, arg);
      }
    });
  }

  function resume(key, arg) {
    try {
      var result = gen[key](arg);
      var value = result.value;
      var wrappedAwait = value instanceof _AwaitValue;
      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {
        if (wrappedAwait) {
          resume("next", arg);
          return;
        }

        settle(result.done ? "return" : "normal", arg);
      }, function (err) {
        resume("throw", err);
      });
    } catch (err) {
      settle("throw", err);
    }
  }

  function settle(type, value) {
    switch (type) {
      case "return":
        front.resolve({
          value: value,
          done: true
        });
        break;

      case "throw":
        front.reject(value);
        break;

      default:
        front.resolve({
          value: value,
          done: false
        });
        break;
    }

    front = front.next;

    if (front) {
      resume(front.key, front.arg);
    } else {
      back = null;
    }
  }

  this._invoke = send;

  if (typeof gen.return !== "function") {
    this.return = undefined;
  }
}

if (typeof Symbol === "function" && Symbol.asyncIterator) {
  _AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
    return this;
  };
}

_AsyncGenerator.prototype.next = function (arg) {
  return this._invoke("next", arg);
};

_AsyncGenerator.prototype.throw = function (arg) {
  return this._invoke("throw", arg);
};

_AsyncGenerator.prototype.return = function (arg) {
  return this._invoke("return", arg);
};

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }

      function _next(value) {
        step("next", value);
      }

      function _throw(err) {
        step("throw", err);
      }

      _next();
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _sliceIterator(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _slicedToArray(arr, i) {
  if (Array.isArray(arr)) {
    return arr;
  } else if (Symbol.iterator in Object(arr)) {
    return _sliceIterator(arr, i);
  } else {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }
}

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
}

/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */
!function (global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  var inModule = (typeof module === "undefined" ? "undefined" : _typeof(module)) === "object";
  var runtime = global.regeneratorRuntime;

  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    } // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.


    return;
  } // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.


  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;

      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  runtime.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && _typeof(value) === "object" && hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  runtime.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  runtime.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function stop() {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
}( // In sloppy mode, unbound `this` refers to the global object, fallback to
// Function constructor if we're in global strict mode. That is sadly a form
// of indirect eval which violates Content Security Policy.
function () {
  return this;
}() || Function("return this")());

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)


var IE_PROTO$2 = _sharedKey('IE_PROTO');
var ObjectProto$1 = Object.prototype;

var _objectGpo = Object.getPrototypeOf || function (O) {
  O = _toObject(O);
  if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto$1 : null;
};

var _iterStep = function (done, value) {
  return { value: value, done: !!done };
};

'use strict';



var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
_hide(IteratorPrototype, _wks('iterator'), function () { return this; });

var _iterCreate = function (Constructor, NAME, next) {
  Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });
  _setToStringTag(Constructor, NAME + ' Iterator');
};

'use strict';









var ITERATOR$3 = _wks('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  _iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR$3] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = _objectGpo($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      _setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!_library && !_has(IteratorPrototype, ITERATOR$3)) _hide(IteratorPrototype, ITERATOR$3, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!_library || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR$3])) {
    _hide(proto, ITERATOR$3, $default);
  }
  // Plug for library
  _iterators[NAME] = $default;
  _iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) _redefine(proto, key, methods[key]);
    } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

'use strict';





// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
  this._t = _toIobject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return _iterStep(1);
  }
  if (kind == 'keys') return _iterStep(0, index);
  if (kind == 'values') return _iterStep(0, O[index]);
  return _iterStep(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
_iterators.Arguments = _iterators.Array;

_addToUnscopables('keys');
_addToUnscopables('values');
_addToUnscopables('entries');

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';




var _arrayCopyWithin = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = _toObject(this);
  var len = _toLength(O.length);
  var to = _toAbsoluteIndex(target, len);
  var from = _toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : _toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};

var _typedArray = createCommonjsModule(function (module) {
'use strict';
if (_descriptors) {
  var LIBRARY = _library;
  var global = _global;
  var fails = _fails;
  var $export = _export;
  var $typed = _typed;
  var $buffer = _typedBuffer;
  var ctx = _ctx;
  var anInstance = _anInstance;
  var propertyDesc = _propertyDesc;
  var hide = _hide;
  var redefineAll = _redefineAll;
  var toInteger = _toInteger;
  var toLength = _toLength;
  var toIndex = _toIndex;
  var toAbsoluteIndex = _toAbsoluteIndex;
  var toPrimitive = _toPrimitive;
  var has = _has;
  var classof = _classof;
  var isObject = _isObject;
  var toObject = _toObject;
  var isArrayIter = _isArrayIter;
  var create = _objectCreate;
  var getPrototypeOf$$1 = _objectGpo;
  var gOPN = _objectGopn.f;
  var getIterFn = core_getIteratorMethod;
  var uid = _uid;
  var wks = _wks;
  var createArrayMethod = _arrayMethods;
  var createArrayIncludes = _arrayIncludes;
  var speciesConstructor = _speciesConstructor;
  var ArrayIterators = es6_array_iterator;
  var Iterators = _iterators;
  var $iterDetect = _iterDetect;
  var setSpecies = _setSpecies;
  var arrayFill = _arrayFill;
  var arrayCopyWithin = _arrayCopyWithin;
  var $DP = _objectDp;
  var $GOPD = _objectGopd;
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf$$1(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };
});

_typedArray('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

'use strict';

var _order = 1;
function tXml(S) {
  var openBracket = '<';
  var openBracketCC = '<'.charCodeAt(0);
  var closeBracket = '>';
  var closeBracketCC = '>'.charCodeAt(0);
  var minusCC = '-'.charCodeAt(0);
  var slashCC = '/'.charCodeAt(0);
  var exclamationCC = '!'.charCodeAt(0);
  var singleQuoteCC = '\''.charCodeAt(0);
  var doubleQuoteCC = '"'.charCodeAt(0);
  var questionMarkCC = '?'.charCodeAt(0);
  /**
   *    returns text until the first nonAlphebetic letter
   */

  var nameSpacer = '\r\n\t>/= ';
  var pos = 0;
  /**
   * Parsing a list of entries
   */

  function parseChildren() {
    var children = [];

    while (S[pos]) {
      if (S.charCodeAt(pos) === openBracketCC) {
        if (S.charCodeAt(pos + 1) === slashCC) {
          // </
          // while (S[pos]!=='>') { pos++; }
          pos = S.indexOf(closeBracket, pos);
          return children;
        } else if (S.charCodeAt(pos + 1) === exclamationCC) {
          // <! or <!--
          if (S.charCodeAt(pos + 2) === minusCC) {
            // comment support
            while (!(S.charCodeAt(pos) === closeBracketCC && S.charCodeAt(pos - 1) === minusCC && S.charCodeAt(pos - 2) === minusCC && pos !== -1)) {
              pos = S.indexOf(closeBracket, pos + 1);
            }

            if (pos === -1) {
              pos = S.length;
            }
          } else {
            // doctype support
            pos += 2;

            for (; S.charCodeAt(pos) !== closeBracketCC; pos++) {}
          }

          pos++;
          continue;
        } else if (S.charCodeAt(pos + 1) === questionMarkCC) {
          // <?
          // XML header support
          pos = S.indexOf(closeBracket, pos);
          pos++;
          continue;
        }

        pos++;
        var startNamePos = pos;

        for (; nameSpacer.indexOf(S[pos]) === -1; pos++) {}

        var nodeTagName = S.slice(startNamePos, pos); // Parsing attributes

        var attrFound = false;
        var nodeAttributes = {};

        for (; S.charCodeAt(pos) !== closeBracketCC; pos++) {
          var c = S.charCodeAt(pos);

          if (c > 64 && c < 91 || c > 96 && c < 123) {
            startNamePos = pos;

            for (; nameSpacer.indexOf(S[pos]) === -1; pos++) {}

            var name = S.slice(startNamePos, pos); // search beginning of the string

            var code = S.charCodeAt(pos);

            while (code !== singleQuoteCC && code !== doubleQuoteCC) {
              pos++;
              code = S.charCodeAt(pos);
            }

            var startChar = S[pos];
            var startStringPos = ++pos;
            pos = S.indexOf(startChar, startStringPos);
            var value = S.slice(startStringPos, pos);

            if (!attrFound) {
              nodeAttributes = {};
              attrFound = true;
            }

            nodeAttributes[name] = value;
          }
        } // Optional parsing of children


        var nodeChildren = void 0;

        if (S.charCodeAt(pos - 1) !== slashCC) {
          pos++;
          nodeChildren = parseChildren();
        }

        children.push({
          'children': nodeChildren,
          'tagName': nodeTagName,
          'attrs': nodeAttributes
        });
      } else {
        var startTextPos = pos;
        pos = S.indexOf(openBracket, pos) - 1; // Skip characters until '<'

        if (pos === -2) {
          pos = S.length;
        }

        var text = S.slice(startTextPos, pos + 1);

        if (text.trim().length > 0) {
          children.push(text);
        }
      }

      pos++;
    }

    return children;
  }

  _order = 1;
  return simplefy(parseChildren());
}

function simplefy(children) {
  var node = {};

  if (children === undefined) {
    return {};
  } // Text node (e.g. <t>This is text.</t>)


  if (children.length === 1 && (typeof children[0] === 'string' || children[0] instanceof String)) {
    // eslint-disable-next-line no-new-wrappers
    return new String(children[0]);
  } // map each object


  children.forEach(function (child) {
    if (!node[child.tagName]) {
      node[child.tagName] = [];
    }

    if (_typeof(child) === 'object') {
      var kids = simplefy(child.children);

      if (child.attrs) {
        kids.attrs = child.attrs;
      }

      if (kids['attrs'] === undefined) {
        kids['attrs'] = {
          'order': _order
        };
      } else {
        kids['attrs']['order'] = _order;
      }

      _order++;
      node[child.tagName].push(kids);
    }
  });

  for (var i in node) {
    if (node[i].length === 1) {
      node[i] = node[i][0];
    }
  }

  return node;
}

/**
 * Colorz (or Colz) is a Javascript "library" to help
 * in color conversion between the usual color-spaces
 * Hex - Rgb - Hsl / Hsv - Hsb
 *
 * It provides some helpers to output Canvas / CSS
 * color strings.
 *
 * by Carlos Cabo 2013
 * http://carloscabo.com
 *
 * Some formulas borrowed from Wikipedia or other authors.
 */
var round = Math.round;
/*
 ==================================
 Color constructors
 ==================================
*/

var Rgb =
/*#__PURE__*/
function () {
  function Rgb(col) {
    _classCallCheck(this, Rgb);
    this.r = col[0];
    this.g = col[1];
    this.b = col[2];
  }

  _createClass(Rgb, [{
    key: "toString",
    value: function toString() {
      return "rgb(".concat(this.r, ",").concat(this.g, ",").concat(this.b, ")");
    }
  }]);
  return Rgb;
}();
var Rgba =
/*#__PURE__*/
function (_Rgb) {
  _inherits(Rgba, _Rgb);

  function Rgba(col) {
    var _this;

    _classCallCheck(this, Rgba);
    _this = _possibleConstructorReturn(this, (Rgba.__proto__ || Object.getPrototypeOf(Rgba)).call(this, col));
    _this.a = col[3];
    return _this;
  }

  _createClass(Rgba, [{
    key: "toString",
    value: function toString() {
      return "rgba(".concat(this.r, ",").concat(this.g, ",").concat(this.b, ",").concat(this.a, ")");
    }
  }]);
  return Rgba;
}(Rgb);
var Hsl =
/*#__PURE__*/
function () {
  function Hsl(col) {
    _classCallCheck(this, Hsl);
    this.h = col[0];
    this.s = col[1];
    this.l = col[2];
  }

  _createClass(Hsl, [{
    key: "toString",
    value: function toString() {
      return "hsl(".concat(this.h, ",").concat(this.s, "%,").concat(this.l, "%)");
    }
  }]);
  return Hsl;
}();
var Hsla =
/*#__PURE__*/
function (_Hsl) {
  _inherits(Hsla, _Hsl);

  function Hsla(col) {
    var _this2;

    _classCallCheck(this, Hsla);
    _this2 = _possibleConstructorReturn(this, (Hsla.__proto__ || Object.getPrototypeOf(Hsla)).call(this, col));
    _this2.a = col[3];
    return _this2;
  }

  _createClass(Hsla, [{
    key: "toString",
    value: function toString() {
      return "hsla(".concat(this.h, ",").concat(this.s, "%,").concat(this.l, "%,").concat(this.a, ")");
    }
  }]);
  return Hsla;
}(Hsl);
/*
 ==================================
 Main Colz color object
 ==================================
*/

var Color =
/*#__PURE__*/
function () {
  function Color(r, g, b) {
    var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.0;
    _classCallCheck(this, Color);

    // If args are not given in (r, g, b, [a]) format, convert
    if (typeof r === 'string') {
      var str = r; // Add initial '#' if missing

      if (str.charAt(0) !== '#') {
        str = '#' + str;
      } // If Hex in #fff format convert to #ffffff


      if (str.length < 7) {
        str = '#' + str[1] + str[1] + str[2] + str[2] + str[3] + str[3];
      }

      var _hexToRgb = hexToRgb(str);

      var _hexToRgb2 = _slicedToArray(_hexToRgb, 3);

      r = _hexToRgb2[0];
      g = _hexToRgb2[1];
      b = _hexToRgb2[2];
    } else if (r instanceof Array) {
      a = r[3] || a;
      b = r[2];
      g = r[1];
      r = r[0];
    }

    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
    this.rgb = new Rgb([this.r, this.g, this.b]);
    this.rgba = new Rgba([this.r, this.g, this.b, this.a]);
    this.hex = rgbToHex(this.r, this.g, this.b);
    this.hsl = new Hsl(rgbToHsl(this.r, this.g, this.b));
    this.h = this.hsl.h;
    this.s = this.hsl.s;
    this.l = this.hsl.l;
    this.hsla = new Hsla([this.h, this.s, this.l, this.a]);
  }

  _createClass(Color, [{
    key: "setHue",
    value: function setHue(newHue) {
      this.h = newHue;
      this.hsl.h = newHue;
      this.hsla.h = newHue;
      this.updateFromHsl();
    }
  }, {
    key: "setSat",
    value: function setSat(newSat) {
      this.s = newSat;
      this.hsl.s = newSat;
      this.hsla.s = newSat;
      this.updateFromHsl();
    }
  }, {
    key: "setLum",
    value: function setLum(newLum) {
      this.l = newLum;
      this.hsl.l = newLum;
      this.hsla.l = newLum;
      this.updateFromHsl();
    }
  }, {
    key: "setAlpha",
    value: function setAlpha(newAlpha) {
      this.a = newAlpha;
      this.hsla.a = newAlpha;
      this.rgba.a = newAlpha;
    }
  }, {
    key: "updateFromHsl",
    value: function updateFromHsl() {
      // Updates Rgb
      this.rgb = null;
      this.rgb = new Rgb(hslToRgb(this.h, this.s, this.l));
      this.r = this.rgb.r;
      this.g = this.rgb.g;
      this.b = this.rgb.b;
      this.rgba.r = this.rgb.r;
      this.rgba.g = this.rgb.g;
      this.rgba.b = this.rgb.b; // Updates Hex

      this.hex = null;
      this.hex = rgbToHex([this.r, this.g, this.b]);
    }
  }]);
  return Color;
}();
/*
 ==================================
 Public Methods
 ==================================
*/


var hexToRgb = function hexToRgb(hex) {
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : null;
};
var componentToHex = function componentToHex(c) {
  var hex = c.toString(16);
  return hex.length === 1 ? '0' + hex : hex;
}; // You can pass 3 numeric values or 1 Array

var rgbToHex = function rgbToHex(r, g, b) {
  if (r instanceof Array) {
    b = r[2];
    g = r[1];
    r = r[0];
  }

  return '#' + componentToHex(r) + componentToHex(g) + componentToHex(b);
};
/**
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 *
 * @param {Number} r The red color value
 * @param {Number} g The green color value
 * @param {Number} b The blue color value
 * @return {Array} The HSL representation
 */

var rgbToHsl = function rgbToHsl(r, g, b) {
  if (r instanceof Array) {
    b = r[2];
    g = r[1];
    r = r[0];
  }

  var h, s, l, d, max, min;
  r /= 255;
  g /= 255;
  b /= 255;
  max = Math.max(r, g, b);
  min = Math.min(r, g, b);
  l = (max + min) / 2;

  if (max === min) {
    h = s = 0; // achromatic
  } else {
    d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;

      case g:
        h = (b - r) / d + 2;
        break;

      case b:
        h = (r - g) / d + 4;
        break;
    }

    h /= 6;
  } // CARLOS


  h = round(h * 360);
  s = round(s * 100);
  l = round(l * 100);
  return [h, s, l];
};
var hue2rgb = function hue2rgb(p, q, t) {
  if (t < 0) {
    t += 1;
  }

  if (t > 1) {
    t -= 1;
  }

  if (t < 1 / 6) {
    return p + (q - p) * 6 * t;
  }

  if (t < 1 / 2) {
    return q;
  }

  if (t < 2 / 3) {
    return p + (q - p) * (2 / 3 - t) * 6;
  }

  return p;
};
/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 *
 * @param {Number} h The hue
 * @param {Number} s The saturation
 * @param {Number} l The lightness
 * @return {Array} The RGB representation
 */

var hslToRgb = function hslToRgb(h, s, l) {
  if (h instanceof Array) {
    l = h[2];
    s = h[1];
    h = h[0];
  }

  h = h / 360;
  s = s / 100;
  l = l / 100;
  var r, g, b, q, p;

  if (s === 0) {
    r = g = b = l; // achromatic
  } else {
    q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }

  return [round(r * 255), round(g * 255), round(b * 255)];
};
/**
 * Converts an RGB color value to HSB / HSV. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 *
 * @param {Number} r The red color value
 * @param {Number} g The green color value
 * @param {Number} b The blue color value
 * @return {Array} The HSB representation
 */


/**
 * Converts an HSB / HSV color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 *
 * @param {Number} h The hue
 * @param {Number} s The saturation
 * @param {Number} v The value
 * @return {Array} The RGB representation
 */


 // alias

/* Convert from Hsv */


 // alias

/*
 ==================================
 Color Scheme Builder
 ==================================
*/

var ColorScheme =
/*#__PURE__*/
function () {
  function ColorScheme(colorVal, angleArray) {
    _classCallCheck(this, ColorScheme);
    this.palette = [];

    if (angleArray === undefined && colorVal instanceof Array) {
      // Asume you passing a color array ['#f00','#0f0'...]
      this.createFromColors(colorVal);
    } else {
      // Create scheme from color + hue angles
      this.createFromAngles(colorVal, angleArray);
    }
  }

  _createClass(ColorScheme, [{
    key: "createFromColors",
    value: function createFromColors(colorVal) {
      for (var i in colorVal) {
        if (colorVal.hasOwnProperty(i)) {
          // console.log(colorVal[i]);
          this.palette.push(new Color(colorVal[i]));
        }
      }

      return this.palette;
    }
  }, {
    key: "createFromAngles",
    value: function createFromAngles(colorVal, angleArray) {
      this.palette.push(new Color(colorVal));

      for (var i in angleArray) {
        if (angleArray.hasOwnProperty(i)) {
          var tempHue = (this.palette[0].h + angleArray[i]) % 360;
          this.palette.push(new Color(hslToRgb(tempHue, this.palette[0].s, this.palette[0].l)));
        }
      }

      return this.palette;
    }
    /* Complementary colors constructors */

  }], [{
    key: "Compl",
    value: function Compl(colorVal) {
      return new this(colorVal, [180]);
    }
    /* Triad */

  }, {
    key: "Triad",
    value: function Triad(colorVal) {
      return new this(colorVal, [120, 240]);
    }
    /* Tetrad */

  }, {
    key: "Tetrad",
    value: function Tetrad(colorVal) {
      return new this(colorVal, [60, 180, 240]);
    }
    /* Analogous */

  }, {
    key: "Analog",
    value: function Analog(colorVal) {
      return new this(colorVal, [-45, 45]);
    }
    /* Split complementary */

  }, {
    key: "Split",
    value: function Split(colorVal) {
      return new this(colorVal, [150, 210]);
    }
    /* Accented Analogous */

  }, {
    key: "Accent",
    value: function Accent(colorVal) {
      return new this(colorVal, [-45, 45, 180]);
    }
  }]);
  return ColorScheme;
}();

/* global btoa, JSZip */
'use strict';

function base64ArrayBuffer(arrayBuff) {
  var buff = new Uint8Array(arrayBuff);
  var text = '';

  for (var i = 0; i < buff.byteLength; i++) {
    text += String.fromCharCode(buff[i]);
  }

  return btoa(text);
}

function extractFileExtension(filename) {
  var dot = filename.lastIndexOf('.');
  if (dot === 0 || dot === -1) return '';
  return filename.substr(filename.lastIndexOf('.') + 1);
}
/*
function escapeHtml (text) {
  const map = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&#039;'
  }
  return text.replace(/[&<>"']/g, m => map[m])
}
*/


function processPptx() {
  var processPPTX = function () {
    var _ref2 = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee2(data) {
      var zip, dateBefore, pptxThumbImg, filesInfo, slideSize, numOfSlides, i, filename, slideHtml, dateAfter;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return JSZip.loadAsync(data);

            case 2:
              zip = _context2.sent;
              dateBefore = new Date();

              if (!(zip.file('docProps/thumbnail.jpeg') !== null)) {
                _context2.next = 9;
                break;
              }

              _context2.next = 7;
              return zip.file('docProps/thumbnail.jpeg').async('base64');

            case 7:
              pptxThumbImg = _context2.sent;
              postMessage({
                'type': 'pptx-thumb',
                'data': pptxThumbImg
              });

            case 9:
              _context2.next = 11;
              return getContentTypes(zip);

            case 11:
              filesInfo = _context2.sent;
              _context2.next = 14;
              return getSlideSize(zip);

            case 14:
              slideSize = _context2.sent;
              _context2.next = 17;
              return loadTheme(zip);

            case 17:
              themeContent = _context2.sent;
              _context2.next = 20;
              return readXmlFile(zip, 'ppt/tableStyles.xml');

            case 20:
              tableStyles = _context2.sent;
              postMessage({
                'type': 'slideSize',
                'data': slideSize
              });
              numOfSlides = filesInfo['slides'].length;
              i = 0;

            case 24:
              if (!(i < numOfSlides)) {
                _context2.next = 34;
                break;
              }

              filename = filesInfo['slides'][i];
              _context2.next = 28;
              return processSingleSlide(zip, filename, i, slideSize);

            case 28:
              slideHtml = _context2.sent;
              postMessage({
                'type': 'slide',
                'data': slideHtml
              });
              postMessage({
                'type': 'progress-update',
                'data': (i + 1) * 100 / numOfSlides
              });

            case 31:
              i++;
              _context2.next = 24;
              break;

            case 34:
              postMessage({
                'type': 'globalCSS',
                'data': genGlobalCSS()
              });
              dateAfter = new Date();
              postMessage({
                'type': 'Done',
                'data': {
                  time: dateAfter - dateBefore,
                  charts: charts
                }
              });

            case 37:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    return function processPPTX(_x2) {
      return _ref2.apply(this, arguments);
    };
  }();

  var readXmlFile = function () {
    var _ref3 = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee3(zip, filename) {
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.t0 = tXml;
              _context3.next = 3;
              return zip.file(filename).async('text');

            case 3:
              _context3.t1 = _context3.sent;
              return _context3.abrupt("return", (0, _context3.t0)(_context3.t1));

            case 5:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    return function readXmlFile(_x3, _x4) {
      return _ref3.apply(this, arguments);
    };
  }();

  var getContentTypes = function () {
    var _ref4 = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee4(zip) {
      var ContentTypesJson, subObj, slidesLocArray, slideLayoutsLocArray, i;
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return readXmlFile(zip, '[Content_Types].xml');

            case 2:
              ContentTypesJson = _context4.sent;
              // console.log('CONTENT TYPES JSON', ContentTypesJson)
              subObj = ContentTypesJson['Types']['Override'];
              slidesLocArray = [];
              slideLayoutsLocArray = [];
              i = 0;

            case 7:
              if (!(i < subObj.length)) {
                _context4.next = 18;
                break;
              }

              _context4.t0 = subObj[i]['attrs']['ContentType'];
              _context4.next = _context4.t0 === 'application/vnd.openxmlformats-officedocument.presentationml.slide+xml' ? 11 : _context4.t0 === 'application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml' ? 13 : 15;
              break;

            case 11:
              slidesLocArray.push(subObj[i]['attrs']['PartName'].substr(1));
              return _context4.abrupt("break", 15);

            case 13:
              slideLayoutsLocArray.push(subObj[i]['attrs']['PartName'].substr(1));
              return _context4.abrupt("break", 15);

            case 15:
              i++;
              _context4.next = 7;
              break;

            case 18:
              return _context4.abrupt("return", {
                'slides': slidesLocArray,
                'slideLayouts': slideLayoutsLocArray
              });

            case 19:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    return function getContentTypes(_x5) {
      return _ref4.apply(this, arguments);
    };
  }();

  var getSlideSize = function () {
    var _ref5 = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee5(zip) {
      var content, sldSzAttrs;
      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return readXmlFile(zip, 'ppt/presentation.xml');

            case 2:
              content = _context5.sent;
              sldSzAttrs = content['p:presentation']['p:sldSz']['attrs'];
              return _context5.abrupt("return", {
                'width': parseInt(sldSzAttrs['cx']) * 96 / 914400,
                'height': parseInt(sldSzAttrs['cy']) * 96 / 914400
              });

            case 5:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    return function getSlideSize(_x6) {
      return _ref5.apply(this, arguments);
    };
  }();

  var loadTheme = function () {
    var _ref6 = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee6(zip) {
      var preResContent, relationshipArray, themeURI, i;
      return regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return readXmlFile(zip, 'ppt/_rels/presentation.xml.rels');

            case 2:
              preResContent = _context6.sent;
              relationshipArray = preResContent['Relationships']['Relationship'];

              if (!(relationshipArray.constructor === Array)) {
                _context6.next = 15;
                break;
              }

              i = 0;

            case 6:
              if (!(i < relationshipArray.length)) {
                _context6.next = 13;
                break;
              }

              if (!(relationshipArray[i]['attrs']['Type'] === 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme')) {
                _context6.next = 10;
                break;
              }

              themeURI = relationshipArray[i]['attrs']['Target'];
              return _context6.abrupt("break", 13);

            case 10:
              i++;
              _context6.next = 6;
              break;

            case 13:
              _context6.next = 16;
              break;

            case 15:
              if (relationshipArray['attrs']['Type'] === 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme') {
                themeURI = relationshipArray['attrs']['Target'];
              }

            case 16:
              if (!(themeURI === undefined)) {
                _context6.next = 18;
                break;
              }

              throw Error('Can\'t open theme file.');

            case 18:
              return _context6.abrupt("return", readXmlFile(zip, 'ppt/' + themeURI));

            case 19:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    return function loadTheme(_x7) {
      return _ref6.apply(this, arguments);
    };
  }();

  var processSingleSlide = function () {
    var _ref7 = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee7(zip, sldFileName, index, slideSize) {
      var resName, resContent, RelationshipArray, layoutFilename, slideResObj, i, slideLayoutContent, slideLayoutTables, sldLayoutClrOvr, slideLayoutResFilename, slideLayoutResContent, masterFilename, layoutResObj, _i, slideMasterContent, slideMasterTextStyles, slideMasterTables, slideMasterResFilename, slideMasterResContent, themeFilename, masterResObj, _i2, slideContent, nodes, warpObj, bgColor, result, nodeKey, _i3;

      return regeneratorRuntime.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              postMessage({
                'type': 'INFO',
                'data': 'Processing slide' + (index + 1)
              }); // =====< Step 1 >=====
              // Read relationship filename of the slide (Get slideLayoutXX.xml)
              // @sldFileName: ppt/slides/slide1.xml
              // @resName: ppt/slides/_rels/slide1.xml.rels

              resName = sldFileName.replace('slides/slide', 'slides/_rels/slide') + '.rels';
              _context7.next = 4;
              return readXmlFile(zip, resName);

            case 4:
              resContent = _context7.sent;
              RelationshipArray = resContent['Relationships']['Relationship'];
              layoutFilename = '';
              slideResObj = {};

              if (!(RelationshipArray.constructor === Array)) {
                _context7.next = 22;
                break;
              }

              i = 0;

            case 10:
              if (!(i < RelationshipArray.length)) {
                _context7.next = 20;
                break;
              }

              _context7.t0 = RelationshipArray[i]['attrs']['Type'];
              _context7.next = _context7.t0 === 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout' ? 14 : _context7.t0 === 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesSlide' ? 16 : _context7.t0 === 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image' ? 16 : _context7.t0 === 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart' ? 16 : _context7.t0 === 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink' ? 16 : 16;
              break;

            case 14:
              layoutFilename = RelationshipArray[i]['attrs']['Target'].replace('../', 'ppt/');
              return _context7.abrupt("break", 17);

            case 16:
              slideResObj[RelationshipArray[i]['attrs']['Id']] = {
                'type': RelationshipArray[i]['attrs']['Type'].replace('http://schemas.openxmlformats.org/officeDocument/2006/relationships/', ''),
                'target': RelationshipArray[i]['attrs']['Target'].replace('../', 'ppt/')
              };

            case 17:
              i++;
              _context7.next = 10;
              break;

            case 20:
              _context7.next = 23;
              break;

            case 22:
              layoutFilename = RelationshipArray['attrs']['Target'].replace('../', 'ppt/');

            case 23:
              _context7.next = 25;
              return readXmlFile(zip, layoutFilename);

            case 25:
              slideLayoutContent = _context7.sent;
              slideLayoutTables = indexNodes(slideLayoutContent);
              sldLayoutClrOvr = slideLayoutContent['p:sldLayout']['p:clrMapOvr']['a:overrideClrMapping']; // console.log(slideLayoutClrOvride);

              if (sldLayoutClrOvr !== undefined) {
                slideLayoutClrOvride = sldLayoutClrOvr['attrs'];
              } // =====< Step 2 >=====
              // Read slide master filename of the slidelayout (Get slideMasterXX.xml)
              // @resName: ppt/slideLayouts/slideLayout1.xml
              // @masterName: ppt/slideLayouts/_rels/slideLayout1.xml.rels


              slideLayoutResFilename = layoutFilename.replace('slideLayouts/slideLayout', 'slideLayouts/_rels/slideLayout') + '.rels';
              _context7.next = 32;
              return readXmlFile(zip, slideLayoutResFilename);

            case 32:
              slideLayoutResContent = _context7.sent;
              RelationshipArray = slideLayoutResContent['Relationships']['Relationship'];
              masterFilename = '';
              layoutResObj = {};

              if (!(RelationshipArray.constructor === Array)) {
                _context7.next = 50;
                break;
              }

              _i = 0;

            case 38:
              if (!(_i < RelationshipArray.length)) {
                _context7.next = 48;
                break;
              }

              _context7.t1 = RelationshipArray[_i]['attrs']['Type'];
              _context7.next = _context7.t1 === 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster' ? 42 : 44;
              break;

            case 42:
              masterFilename = RelationshipArray[_i]['attrs']['Target'].replace('../', 'ppt/');
              return _context7.abrupt("break", 45);

            case 44:
              layoutResObj[RelationshipArray[_i]['attrs']['Id']] = {
                'type': RelationshipArray[_i]['attrs']['Type'].replace('http://schemas.openxmlformats.org/officeDocument/2006/relationships/', ''),
                'target': RelationshipArray[_i]['attrs']['Target'].replace('../', 'ppt/')
              };

            case 45:
              _i++;
              _context7.next = 38;
              break;

            case 48:
              _context7.next = 51;
              break;

            case 50:
              masterFilename = RelationshipArray['attrs']['Target'].replace('../', 'ppt/');

            case 51:
              _context7.next = 53;
              return readXmlFile(zip, masterFilename);

            case 53:
              slideMasterContent = _context7.sent;
              slideMasterTextStyles = getTextByPathList(slideMasterContent, ['p:sldMaster', 'p:txStyles']);
              slideMasterTables = indexNodes(slideMasterContent); // ///////////////Amir/////////////
              // Open slideMasterXX.xml.rels

              slideMasterResFilename = masterFilename.replace('slideMasters/slideMaster', 'slideMasters/_rels/slideMaster') + '.rels';
              _context7.next = 59;
              return readXmlFile(zip, slideMasterResFilename);

            case 59:
              slideMasterResContent = _context7.sent;
              RelationshipArray = slideMasterResContent['Relationships']['Relationship'];
              themeFilename = '';
              masterResObj = {};

              if (!(RelationshipArray.constructor === Array)) {
                _context7.next = 77;
                break;
              }

              _i2 = 0;

            case 65:
              if (!(_i2 < RelationshipArray.length)) {
                _context7.next = 75;
                break;
              }

              _context7.t2 = RelationshipArray[_i2]['attrs']['Type'];
              _context7.next = _context7.t2 === 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme' ? 69 : 71;
              break;

            case 69:
              themeFilename = RelationshipArray[_i2]['attrs']['Target'].replace('../', 'ppt/');
              return _context7.abrupt("break", 72);

            case 71:
              masterResObj[RelationshipArray[_i2]['attrs']['Id']] = {
                'type': RelationshipArray[_i2]['attrs']['Type'].replace('http://schemas.openxmlformats.org/officeDocument/2006/relationships/', ''),
                'target': RelationshipArray[_i2]['attrs']['Target'].replace('../', 'ppt/')
              };

            case 72:
              _i2++;
              _context7.next = 65;
              break;

            case 75:
              _context7.next = 78;
              break;

            case 77:
              themeFilename = RelationshipArray['attrs']['Target'].replace('../', 'ppt/');

            case 78:
              if (!(themeFilename !== undefined)) {
                _context7.next = 82;
                break;
              }

              _context7.next = 81;
              return readXmlFile(zip, themeFilename);

            case 81:
              themeContent = _context7.sent;

            case 82:
              _context7.next = 84;
              return readXmlFile(zip, sldFileName);

            case 84:
              slideContent = _context7.sent;
              nodes = slideContent['p:sld']['p:cSld']['p:spTree'];
              warpObj = {
                'zip': zip,
                'slideLayoutTables': slideLayoutTables,
                'slideMasterTables': slideMasterTables,
                'slideResObj': slideResObj,
                'slideMasterTextStyles': slideMasterTextStyles,
                'layoutResObj': layoutResObj,
                'masterResObj': masterResObj
              };
              bgColor = getSlideBackgroundFill(slideContent, slideLayoutContent, slideMasterContent, warpObj);
              result = '<section style=\'width:' + slideSize.width + 'px; height:' + slideSize.height + 'px;' + bgColor + '\'>';
              _context7.t3 = regeneratorRuntime.keys(nodes);

            case 90:
              if ((_context7.t4 = _context7.t3()).done) {
                _context7.next = 108;
                break;
              }

              nodeKey = _context7.t4.value;

              if (!(nodes[nodeKey].constructor === Array)) {
                _context7.next = 103;
                break;
              }

              _i3 = 0;

            case 94:
              if (!(_i3 < nodes[nodeKey].length)) {
                _context7.next = 101;
                break;
              }

              _context7.next = 97;
              return processNodesInSlide(nodeKey, nodes[nodeKey][_i3], warpObj);

            case 97:
              result += _context7.sent;

            case 98:
              _i3++;
              _context7.next = 94;
              break;

            case 101:
              _context7.next = 106;
              break;

            case 103:
              _context7.next = 105;
              return processNodesInSlide(nodeKey, nodes[nodeKey], warpObj);

            case 105:
              result += _context7.sent;

            case 106:
              _context7.next = 90;
              break;

            case 108:
              return _context7.abrupt("return", result + '</section>');

            case 109:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    return function processSingleSlide(_x8, _x9, _x10, _x11) {
      return _ref7.apply(this, arguments);
    };
  }();

  var processNodesInSlide = function () {
    var _ref8 = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee8(nodeKey, nodeValue, warpObj) {
      var result;
      return regeneratorRuntime.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              result = '';
              _context8.t0 = nodeKey;
              _context8.next = _context8.t0 === 'p:sp' ? 4 : _context8.t0 === 'p:cxnSp' ? 6 : _context8.t0 === 'p:pic' ? 8 : _context8.t0 === 'p:graphicFrame' ? 10 : _context8.t0 === 'p:grpSp' ? 14 : 18;
              break;

            case 4:
              // Shape, Text
              result = processSpNode(nodeValue, warpObj);
              return _context8.abrupt("break", 18);

            case 6:
              // Shape, Text (with connection)
              result = processCxnSpNode(nodeValue, warpObj);
              return _context8.abrupt("break", 18);

            case 8:
              // Picture
              result = processPicNode(nodeValue, warpObj);
              return _context8.abrupt("break", 18);

            case 10:
              _context8.next = 12;
              return processGraphicFrameNode(nodeValue, warpObj);

            case 12:
              result = _context8.sent;
              return _context8.abrupt("break", 18);

            case 14:
              _context8.next = 16;
              return processGroupSpNode(nodeValue, warpObj);

            case 16:
              result = _context8.sent;
              return _context8.abrupt("break", 18);

            case 18:
              return _context8.abrupt("return", result);

            case 19:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    return function processNodesInSlide(_x12, _x13, _x14) {
      return _ref8.apply(this, arguments);
    };
  }();

  var processGroupSpNode = function () {
    var _ref9 = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee9(node, warpObj) {
      var factor, xfrmNode, x, y, chx, chy, cx, cy, chcx, chcy, order, result, nodeKey, i;
      return regeneratorRuntime.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              factor = 96 / 914400;
              xfrmNode = node['p:grpSpPr']['a:xfrm'];
              x = parseInt(xfrmNode['a:off']['attrs']['x']) * factor;
              y = parseInt(xfrmNode['a:off']['attrs']['y']) * factor;
              chx = parseInt(xfrmNode['a:chOff']['attrs']['x']) * factor;
              chy = parseInt(xfrmNode['a:chOff']['attrs']['y']) * factor;
              cx = parseInt(xfrmNode['a:ext']['attrs']['cx']) * factor;
              cy = parseInt(xfrmNode['a:ext']['attrs']['cy']) * factor;
              chcx = parseInt(xfrmNode['a:chExt']['attrs']['cx']) * factor;
              chcy = parseInt(xfrmNode['a:chExt']['attrs']['cy']) * factor;
              order = node['attrs']['order'];
              result = '<div class=\'block group\' style=\'z-index: ' + order + '; top: ' + (y - chy) + 'px; left: ' + (x - chx) + 'px; width: ' + (cx - chcx) + 'px; height: ' + (cy - chcy) + 'px;\'>'; // Procsee all child nodes

              _context9.t0 = regeneratorRuntime.keys(node);

            case 13:
              if ((_context9.t1 = _context9.t0()).done) {
                _context9.next = 31;
                break;
              }

              nodeKey = _context9.t1.value;

              if (!(node[nodeKey].constructor === Array)) {
                _context9.next = 26;
                break;
              }

              i = 0;

            case 17:
              if (!(i < node[nodeKey].length)) {
                _context9.next = 24;
                break;
              }

              _context9.next = 20;
              return processNodesInSlide(nodeKey, node[nodeKey][i], warpObj);

            case 20:
              result += _context9.sent;

            case 21:
              i++;
              _context9.next = 17;
              break;

            case 24:
              _context9.next = 29;
              break;

            case 26:
              _context9.next = 28;
              return processNodesInSlide(nodeKey, node[nodeKey], warpObj);

            case 28:
              result += _context9.sent;

            case 29:
              _context9.next = 13;
              break;

            case 31:
              result += '</div>';
              return _context9.abrupt("return", result);

            case 33:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));

    return function processGroupSpNode(_x15, _x16) {
      return _ref9.apply(this, arguments);
    };
  }();

  var processGraphicFrameNode = function () {
    var _ref10 = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee10(node, warpObj) {
      var result, graphicTypeUri;
      return regeneratorRuntime.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              result = '';
              graphicTypeUri = getTextByPathList(node, ['a:graphic', 'a:graphicData', 'attrs', 'uri']);
              _context10.t0 = graphicTypeUri;
              _context10.next = _context10.t0 === 'http://schemas.openxmlformats.org/drawingml/2006/table' ? 5 : _context10.t0 === 'http://schemas.openxmlformats.org/drawingml/2006/chart' ? 7 : _context10.t0 === 'http://schemas.openxmlformats.org/drawingml/2006/diagram' ? 11 : 13;
              break;

            case 5:
              result = genTable(node, warpObj);
              return _context10.abrupt("break", 13);

            case 7:
              _context10.next = 9;
              return genChart(node, warpObj);

            case 9:
              result = _context10.sent;
              return _context10.abrupt("break", 13);

            case 11:
              result = genDiagram(node, warpObj);
              return _context10.abrupt("break", 13);

            case 13:
              return _context10.abrupt("return", result);

            case 14:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));

    return function processGraphicFrameNode(_x17, _x18) {
      return _ref10.apply(this, arguments);
    };
  }();
  /*
  function processSpPrNode (node, warpObj) {
  /!*
     * 2241 <xsd:complexType name="CT_ShapeProperties">
     * 2242   <xsd:sequence>
     * 2243     <xsd:element name="xfrm" type="CT_Transform2D"  minOccurs="0" maxOccurs="1"/>
     * 2244     <xsd:group   ref="EG_Geometry"                  minOccurs="0" maxOccurs="1"/>
     * 2245     <xsd:group   ref="EG_FillProperties"            minOccurs="0" maxOccurs="1"/>
     * 2246     <xsd:element name="ln" type="CT_LineProperties" minOccurs="0" maxOccurs="1"/>
     * 2247     <xsd:group   ref="EG_EffectProperties"          minOccurs="0" maxOccurs="1"/>
     * 2248     <xsd:element name="scene3d" type="CT_Scene3D"   minOccurs="0" maxOccurs="1"/>
     * 2249     <xsd:element name="sp3d" type="CT_Shape3D"      minOccurs="0" maxOccurs="1"/>
     * 2250     <xsd:element name="extLst" type="CT_OfficeArtExtensionList" minOccurs="0" maxOccurs="1"/>
     * 2251   </xsd:sequence>
     * 2252   <xsd:attribute name="bwMode" type="ST_BlackWhiteMode" use="optional"/>
     * 2253 </xsd:complexType>
     *!/
   // TODO:
  }
  */


  var genChart = function () {
    var _ref11 = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee11(node, warpObj) {
      var order, xfrmNode, result, rid, refName, content, plotArea, chartData, key;
      return regeneratorRuntime.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              order = node['attrs']['order'];
              xfrmNode = getTextByPathList(node, ['p:xfrm']);
              result = '<div id=\'chart' + chartID + '\' class=\'block content\' style=\'' + getPosition(xfrmNode, undefined, undefined) + getSize(xfrmNode, undefined, undefined) + ' z-index: ' + order + ';\'></div>';
              rid = node['a:graphic']['a:graphicData']['c:chart']['attrs']['r:id'];
              refName = warpObj['slideResObj'][rid]['target'];
              _context11.next = 7;
              return readXmlFile(warpObj['zip'], refName);

            case 7:
              content = _context11.sent;
              plotArea = getTextByPathList(content, ['c:chartSpace', 'c:chart', 'c:plotArea']);
              chartData = null;
              _context11.t0 = regeneratorRuntime.keys(plotArea);

            case 11:
              if ((_context11.t1 = _context11.t0()).done) {
                _context11.next = 32;
                break;
              }

              key = _context11.t1.value;
              _context11.t2 = key;
              _context11.next = _context11.t2 === 'c:lineChart' ? 16 : _context11.t2 === 'c:barChart' ? 18 : _context11.t2 === 'c:pieChart' ? 20 : _context11.t2 === 'c:pie3DChart' ? 22 : _context11.t2 === 'c:areaChart' ? 24 : _context11.t2 === 'c:scatterChart' ? 26 : _context11.t2 === 'c:catAx' ? 28 : _context11.t2 === 'c:valAx' ? 29 : 30;
              break;

            case 16:
              chartData = {
                'type': 'createChart',
                'data': {
                  'chartID': 'chart' + chartID,
                  'chartType': 'lineChart',
                  'chartData': extractChartData(plotArea[key]['c:ser'])
                }
              };
              return _context11.abrupt("break", 30);

            case 18:
              chartData = {
                'type': 'createChart',
                'data': {
                  'chartID': 'chart' + chartID,
                  'chartType': 'barChart',
                  'chartData': extractChartData(plotArea[key]['c:ser'])
                }
              };
              return _context11.abrupt("break", 30);

            case 20:
              chartData = {
                'type': 'createChart',
                'data': {
                  'chartID': 'chart' + chartID,
                  'chartType': 'pieChart',
                  'chartData': extractChartData(plotArea[key]['c:ser'])
                }
              };
              return _context11.abrupt("break", 30);

            case 22:
              chartData = {
                'type': 'createChart',
                'data': {
                  'chartID': 'chart' + chartID,
                  'chartType': 'pie3DChart',
                  'chartData': extractChartData(plotArea[key]['c:ser'])
                }
              };
              return _context11.abrupt("break", 30);

            case 24:
              chartData = {
                'type': 'createChart',
                'data': {
                  'chartID': 'chart' + chartID,
                  'chartType': 'areaChart',
                  'chartData': extractChartData(plotArea[key]['c:ser'])
                }
              };
              return _context11.abrupt("break", 30);

            case 26:
              chartData = {
                'type': 'createChart',
                'data': {
                  'chartID': 'chart' + chartID,
                  'chartType': 'scatterChart',
                  'chartData': extractChartData(plotArea[key]['c:ser'])
                }
              };
              return _context11.abrupt("break", 30);

            case 28:
              return _context11.abrupt("break", 30);

            case 29:
              return _context11.abrupt("break", 30);

            case 30:
              _context11.next = 11;
              break;

            case 32:
              if (chartData !== null) {
                charts.push(chartData);
              }

              chartID++;
              return _context11.abrupt("return", result);

            case 35:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));

    return function genChart(_x19, _x20) {
      return _ref11.apply(this, arguments);
    };
  }();

  var setOnMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
  var postMessage = arguments[1];
  var charts = [];
  var chartID = 0;
  var themeContent = null;
  var slideLayoutClrOvride = '';
  var styleTable = {};
  var tableStyles;
  setOnMessage(function () {
    var _ref = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee(e) {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.t0 = e.type;
              _context.next = _context.t0 === 'processPPTX' ? 3 : 13;
              break;

            case 3:
              _context.prev = 3;
              _context.next = 6;
              return processPPTX(e.data);

            case 6:
              _context.next = 12;
              break;

            case 8:
              _context.prev = 8;
              _context.t1 = _context["catch"](3);
              console.error('AN ERROR HAPPENED DURING processPPTX', _context.t1);
              postMessage({
                type: 'ERROR',
                data: _context.t1.toString()
              });

            case 12:
              return _context.abrupt("break", 13);

            case 13:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[3, 8]]);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }());

  function indexNodes(content) {
    var keys = Object.keys(content);
    var spTreeNode = content[keys[0]]['p:cSld']['p:spTree'];
    var idTable = {};
    var idxTable = {};
    var typeTable = {};

    for (var key in spTreeNode) {
      if (key === 'p:nvGrpSpPr' || key === 'p:grpSpPr') {
        continue;
      }

      var targetNode = spTreeNode[key];

      if (targetNode.constructor === Array) {
        for (var i = 0; i < targetNode.length; i++) {
          var nvSpPrNode = targetNode[i]['p:nvSpPr'];
          var id = getTextByPathList(nvSpPrNode, ['p:cNvPr', 'attrs', 'id']);
          var idx = getTextByPathList(nvSpPrNode, ['p:nvPr', 'p:ph', 'attrs', 'idx']);
          var type = getTextByPathList(nvSpPrNode, ['p:nvPr', 'p:ph', 'attrs', 'type']);

          if (id !== undefined) {
            idTable[id] = targetNode[i];
          }

          if (idx !== undefined) {
            idxTable[idx] = targetNode[i];
          }

          if (type !== undefined) {
            typeTable[type] = targetNode[i];
          }
        }
      } else {
        var _nvSpPrNode = targetNode['p:nvSpPr'];

        var _id = getTextByPathList(_nvSpPrNode, ['p:cNvPr', 'attrs', 'id']);

        var _idx = getTextByPathList(_nvSpPrNode, ['p:nvPr', 'p:ph', 'attrs', 'idx']);

        var _type = getTextByPathList(_nvSpPrNode, ['p:nvPr', 'p:ph', 'attrs', 'type']);

        if (_id !== undefined) {
          idTable[_id] = targetNode;
        }

        if (_idx !== undefined) {
          idxTable[_idx] = targetNode;
        }

        if (_type !== undefined) {
          typeTable[_type] = targetNode;
        }
      }
    }

    return {
      'idTable': idTable,
      'idxTable': idxTable,
      'typeTable': typeTable
    };
  }

  function processSpNode(node, warpObj) {
    /*
     *  958    <xsd:complexType name="CT_GvmlShape">
     *  959   <xsd:sequence>
     *  960     <xsd:element name="nvSpPr" type="CT_GvmlShapeNonVisual"     minOccurs="1" maxOccurs="1"/>
     *  961     <xsd:element name="spPr"   type="CT_ShapeProperties"        minOccurs="1" maxOccurs="1"/>
     *  962     <xsd:element name="txSp"   type="CT_GvmlTextShape"          minOccurs="0" maxOccurs="1"/>
     *  963     <xsd:element name="style"  type="CT_ShapeStyle"             minOccurs="0" maxOccurs="1"/>
     *  964     <xsd:element name="extLst" type="CT_OfficeArtExtensionList" minOccurs="0" maxOccurs="1"/>
     *  965   </xsd:sequence>
     *  966 </xsd:complexType>
     */
    var id = node['p:nvSpPr']['p:cNvPr']['attrs']['id'];
    var name = node['p:nvSpPr']['p:cNvPr']['attrs']['name'];
    var idx = node['p:nvSpPr']['p:nvPr']['p:ph'] === undefined ? undefined : node['p:nvSpPr']['p:nvPr']['p:ph']['attrs']['idx'];
    var type = node['p:nvSpPr']['p:nvPr']['p:ph'] === undefined ? undefined : node['p:nvSpPr']['p:nvPr']['p:ph']['attrs']['type'];
    var order = node['attrs']['order'];
    var slideLayoutSpNode;
    var slideMasterSpNode;

    if (type !== undefined) {
      if (idx !== undefined) {
        slideLayoutSpNode = warpObj['slideLayoutTables']['typeTable'][type];
        slideMasterSpNode = warpObj['slideMasterTables']['typeTable'][type];
      } else {
        slideLayoutSpNode = warpObj['slideLayoutTables']['typeTable'][type];
        slideMasterSpNode = warpObj['slideMasterTables']['typeTable'][type];
      }
    } else {
      if (idx !== undefined) {
        slideLayoutSpNode = warpObj['slideLayoutTables']['idxTable'][idx];
        slideMasterSpNode = warpObj['slideMasterTables']['idxTable'][idx];
      } else {// Nothing
      }
    }

    if (type === undefined) {
      type = getTextByPathList(slideLayoutSpNode, ['p:nvSpPr', 'p:nvPr', 'p:ph', 'attrs', 'type']);

      if (type === undefined) {
        type = getTextByPathList(slideMasterSpNode, ['p:nvSpPr', 'p:nvPr', 'p:ph', 'attrs', 'type']);
      }
    }

    return genShape(node, slideLayoutSpNode, slideMasterSpNode, id, name, idx, type, order, warpObj);
  }

  function processCxnSpNode(node, warpObj) {
    var id = node['p:nvCxnSpPr']['p:cNvPr']['attrs']['id'];
    var name = node['p:nvCxnSpPr']['p:cNvPr']['attrs']['name']; // const idx = (node["p:nvCxnSpPr"]["p:nvPr"]["p:ph"] === undefined) ? undefined : node["p:nvSpPr"]["p:nvPr"]["p:ph"]["attrs"]["idx"];
    // const type = (node["p:nvCxnSpPr"]["p:nvPr"]["p:ph"] === undefined) ? undefined : node["p:nvSpPr"]["p:nvPr"]["p:ph"]["attrs"]["type"];
    // <p:cNvCxnSpPr>(<p:cNvCxnSpPr>, <a:endCxn>)

    var order = node['attrs']['order'];
    return genShape(node, undefined, undefined, id, name, undefined, undefined, order, warpObj);
  }

  function genShape(node, slideLayoutSpNode, slideMasterSpNode, id, name, idx, type, order, warpObj) {
    var xfrmList = ['p:spPr', 'a:xfrm'];
    var slideXfrmNode = getTextByPathList(node, xfrmList);
    var slideLayoutXfrmNode = getTextByPathList(slideLayoutSpNode, xfrmList);
    var slideMasterXfrmNode = getTextByPathList(slideMasterSpNode, xfrmList);
    var result = '';
    var shpId = getTextByPathList(node, ['attrs', 'order']); // console.log("shpId: ",shpId)

    var shapType = getTextByPathList(node, ['p:spPr', 'a:prstGeom', 'attrs', 'prst']); // custGeom - Amir

    var custShapType = getTextByPathList(node, ['p:spPr', 'a:custGeom']);
    var isFlipV = false;

    if (getTextByPathList(slideXfrmNode, ['attrs', 'flipV']) === '1' || getTextByPathList(slideXfrmNode, ['attrs', 'flipH']) === '1') {
      isFlipV = true;
    } // ///////////////////////Amir////////////////////////
    // rotate


    var rotate = angleToDegrees(getTextByPathList(slideXfrmNode, ['attrs', 'rot'])); // console.log("rotate: "+rotate);
    // ////////////////////////////////////////////////

    var w;
    var h;
    var border;
    var headEndNodeAttrs;
    var tailEndNodeAttrs;
    var fillColor;
    var grndFillFlg = false;
    var imgFillFlg = false;

    if (shapType !== undefined || custShapType !== undefined) {
      // const off = getTextByPathList(slideXfrmNode, ['a:off', 'attrs'])
      // const x = parseInt(off['x']) * 96 / 914400
      // const y = parseInt(off['y']) * 96 / 914400
      var ext = getTextByPathList(slideXfrmNode, ['a:ext', 'attrs']);
      w = parseInt(ext['cx']) * 96 / 914400;
      h = parseInt(ext['cy']) * 96 / 914400;
      result += '<svg class=\'drawing\' _id=\'' + id + '\' _idx=\'' + idx + '\' _type=\'' + type + '\' Name=\'' + name + '\' style=\'' + getPosition(slideXfrmNode, undefined, undefined) + getSize(slideXfrmNode, undefined, undefined) + ' z-index: ' + order + ';' + 'transform: rotate(' + rotate + 'deg);' + '\'>';
      result += '<defs>'; // Fill Color

      fillColor = getShapeFill(node, true, warpObj);
      var clrFillType = getFillType(getTextByPathList(node, ['p:spPr'])); // ///////////////////////////////////////

      if (clrFillType === 'GRADIENT_FILL') {
        grndFillFlg = true;
        var colorArray = fillColor.color;
        var angl = fillColor.rot;
        var svgGrdnt = getSvgGradient(w, h, angl, colorArray, shpId); // fill="url(#linGrd)"

        result += svgGrdnt;
      } else if (clrFillType === 'PIC_FILL') {
        imgFillFlg = true;
        var svgBgImg = getSvgImagePattern(fillColor, shpId); // fill="url(#imgPtrn)"
        // console.log(svgBgImg)

        result += svgBgImg;
      } // Border Color


      border = getBorder(node, true);
      headEndNodeAttrs = getTextByPathList(node, ['p:spPr', 'a:ln', 'a:headEnd', 'attrs']);
      tailEndNodeAttrs = getTextByPathList(node, ['p:spPr', 'a:ln', 'a:tailEnd', 'attrs']); // type: none, triangle, stealth, diamond, oval, arrow

      if (headEndNodeAttrs !== undefined && (headEndNodeAttrs['type'] === 'triangle' || headEndNodeAttrs['type'] === 'arrow') || tailEndNodeAttrs !== undefined && (tailEndNodeAttrs['type'] === 'triangle' || tailEndNodeAttrs['type'] === 'arrow')) {
        var triangleMarker = '<marker id=\'markerTriangle_' + shpId + '\' viewBox=\'0 0 10 10\' refX=\'1\' refY=\'5\' markerWidth=\'5\' markerHeight=\'5\' stroke=\'' + border.color + '\' fill=\'' + border.color + '\' orient=\'auto-start-reverse\' markerUnits=\'strokeWidth\'><path d=\'M 0 0 L 10 5 L 0 10 z\' /></marker>';
        result += triangleMarker;
      }

      result += '</defs>';
    }

    if (shapType !== undefined && custShapType === undefined) {
      switch (shapType) {
        case 'accentBorderCallout1':
        case 'accentBorderCallout2':
        case 'accentBorderCallout3':
        case 'accentCallout1':
        case 'accentCallout2':
        case 'accentCallout3':
        case 'actionButtonBackPrevious':
        case 'actionButtonBeginning':
        case 'actionButtonBlank':
        case 'actionButtonDocument':
        case 'actionButtonEnd':
        case 'actionButtonForwardNext':
        case 'actionButtonHelp':
        case 'actionButtonHome':
        case 'actionButtonInformation':
        case 'actionButtonMovie':
        case 'actionButtonReturn':
        case 'actionButtonSound':
        case 'arc':
        case 'bevel':
        case 'blockArc':
        case 'borderCallout1':
        case 'borderCallout2':
        case 'borderCallout3':
        case 'bracePair':
        case 'bracketPair':
        case 'callout1':
        case 'callout2':
        case 'callout3':
        case 'can':
        case 'chartPlus':
        case 'chartStar':
        case 'chartX':
        case 'chevron':
        case 'chord':
        case 'cloud':
        case 'cloudCallout':
        case 'corner':
        case 'cornerTabs':
        case 'cube':
        case 'diagStripe':
        case 'donut':
        case 'doubleWave':
        case 'downArrowCallout':
        case 'ellipseRibbon':
        case 'ellipseRibbon2':
        case 'flowChartAlternateProcess':
        case 'flowChartCollate':
        case 'flowChartConnector':
        case 'flowChartDecision':
        case 'flowChartDelay':
        case 'flowChartDisplay':
        case 'flowChartDocument':
        case 'flowChartExtract':
        case 'flowChartInputOutput':
        case 'flowChartInternalStorage':
        case 'flowChartMagneticDisk':
        case 'flowChartMagneticDrum':
        case 'flowChartMagneticTape':
        case 'flowChartManualInput':
        case 'flowChartManualOperation':
        case 'flowChartMerge':
        case 'flowChartMultidocument':
        case 'flowChartOfflineStorage':
        case 'flowChartOffpageConnector':
        case 'flowChartOnlineStorage':
        case 'flowChartOr':
        case 'flowChartPredefinedProcess':
        case 'flowChartPreparation':
        case 'flowChartProcess':
        case 'flowChartPunchedCard':
        case 'flowChartPunchedTape':
        case 'flowChartSort':
        case 'flowChartSummingJunction':
        case 'flowChartTerminator':
        case 'folderCorner':
        case 'frame':
        case 'funnel':
        case 'gear6':
        case 'gear9':
        case 'halfFrame':
        case 'heart':
        case 'homePlate':
        case 'horizontalScroll':
        case 'irregularSeal1':
        case 'irregularSeal2':
        case 'leftArrowCallout':
        case 'leftBrace':
        case 'leftBracket':
        case 'leftRightArrowCallout':
        case 'leftRightRibbon':
        case 'lightningBolt':
        case 'lineInv':
        case 'mathDivide':
        case 'mathEqual':
        case 'mathMinus':
        case 'mathMultiply':
        case 'mathNotEqual':
        case 'mathPlus':
        case 'moon':
        case 'nonIsoscelesTrapezoid':
        case 'noSmoking':
        case 'pie':
        case 'pieWedge':
        case 'plaque':
        case 'plaqueTabs':
        case 'quadArrowCallout':
        case 'rect':
        case 'ribbon':
        case 'ribbon2':
        case 'rightArrowCallout':
        case 'rightBrace':
        case 'rightBracket':
        case 'round1Rect':
        case 'round2DiagRect':
        case 'round2SameRect':
        case 'smileyFace':
        case 'snip1Rect':
        case 'snip2DiagRect':
        case 'snip2SameRect':
        case 'snipRoundRect':
        case 'squareTabs':
        case 'star10':
        case 'star12':
        case 'star16':
        case 'star24':
        case 'star32':
        case 'star4':
        case 'star5':
        case 'star6':
        case 'star7':
        case 'star8':
        case 'sun':
        case 'teardrop':
        case 'upArrowCallout':
        case 'upDownArrowCallout':
        case 'verticalScroll':
        case 'wave':
        case 'wedgeEllipseCallout':
        case 'wedgeRectCallout':
        case 'wedgeRoundRectCallout':
          {
            result += '<rect x=\'0\' y=\'0\' width=\'' + w + '\' height=\'' + h + '\' fill=\'' + (!imgFillFlg ? grndFillFlg ? 'url(#linGrd_' + shpId + ')' : fillColor : 'url(#imgPtrn_' + shpId + ')') + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' />';
            break;
          }

        case 'ellipse':
          {
            result += '<ellipse cx=\'' + w / 2 + '\' cy=\'' + h / 2 + '\' rx=\'' + w / 2 + '\' ry=\'' + h / 2 + '\' fill=\'' + (!imgFillFlg ? grndFillFlg ? 'url(#linGrd_' + shpId + ')' : fillColor : 'url(#imgPtrn_' + shpId + ')') + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' />';
            break;
          }

        case 'roundRect':
          {
            result += '<rect x=\'0\' y=\'0\' width=\'' + w + '\' height=\'' + h + '\' rx=\'7\' ry=\'7\' fill=\'' + (!imgFillFlg ? grndFillFlg ? 'url(#linGrd_' + shpId + ')' : fillColor : 'url(#imgPtrn_' + shpId + ')') + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' />';
            break;
          }

        case 'bentConnector2':
          {
            // 直角 (path)
            var d;

            if (isFlipV) {
              d = 'M 0 ' + w + ' L ' + h + ' ' + w + ' L ' + h + ' 0';
            } else {
              d = 'M ' + w + ' 0 L ' + w + ' ' + h + ' L 0 ' + h;
            }

            result += '<path d=\'' + d + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' fill=\'none\' ';

            if (headEndNodeAttrs !== undefined && (headEndNodeAttrs['type'] === 'triangle' || headEndNodeAttrs['type'] === 'arrow')) {
              result += 'marker-start=\'url(#markerTriangle_' + shpId + ')\' ';
            }

            if (tailEndNodeAttrs !== undefined && (tailEndNodeAttrs['type'] === 'triangle' || tailEndNodeAttrs['type'] === 'arrow')) {
              result += 'marker-end=\'url(#markerTriangle_' + shpId + ')\' ';
            }

            result += '/>';
            break;
          }

        case 'rtTriangle':
          {
            result += ' <polygon points=\'0 0,0 ' + h + ',' + w + ' ' + h + '\' fill=\'' + (!imgFillFlg ? grndFillFlg ? 'url(#linGrd_' + shpId + ')' : fillColor : 'url(#imgPtrn_' + shpId + ')') + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' />';
            break;
          }

        case 'triangle':
          {
            var shapAdjst = getTextByPathList(node, ['p:spPr', 'a:prstGeom', 'a:avLst', 'a:gd', 'attrs', 'fmla']);
            var shapAdjstVal = 0.5;

            if (shapAdjst !== undefined) {
              shapAdjstVal = parseInt(shapAdjst.substr(4)) * 96 / 9144000; // console.log("w: "+w+"\nh: "+h+"\nshapAdjst: "+shapAdjst+"\nshapAdjstVal: "+shapAdjstVal);
            }

            result += ' <polygon points=\'' + w * shapAdjstVal + ' 0,0 ' + h + ',' + w + ' ' + h + '\' fill=\'' + (!imgFillFlg ? grndFillFlg ? 'url(#linGrd_' + shpId + ')' : fillColor : 'url(#imgPtrn_' + shpId + ')') + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' />';
            break;
          }

        case 'diamond':
          {
            result += ' <polygon points=\'' + w / 2 + ' 0,0 ' + h / 2 + ',' + w / 2 + ' ' + h + ',' + w + ' ' + h / 2 + '\' fill=\'' + (!imgFillFlg ? grndFillFlg ? 'url(#linGrd_' + shpId + ')' : fillColor : 'url(#imgPtrn_' + shpId + ')') + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' />';
            break;
          }

        case 'trapezoid':
          {
            var _shapAdjst = getTextByPathList(node, ['p:spPr', 'a:prstGeom', 'a:avLst', 'a:gd', 'attrs', 'fmla']);

            var adjstVal = 0.25;
            var maxAdjConst = 0.7407;

            if (_shapAdjst !== undefined) {
              var adjst = parseInt(_shapAdjst.substr(4)) * 96 / 9144000;
              adjstVal = adjst * 0.5 / maxAdjConst; // console.log("w: "+w+"\nh: "+h+"\nshapAdjst: "+shapAdjst+"\nadjstVal: "+adjstVal);
            }

            result += ' <polygon points=\'' + w * adjstVal + ' 0,0 ' + h + ',' + w + ' ' + h + ',' + (1 - adjstVal) * w + ' 0\' fill=\'' + (!imgFillFlg ? grndFillFlg ? 'url(#linGrd_' + shpId + ')' : fillColor : 'url(#imgPtrn_' + shpId + ')') + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' />';
            break;
          }

        case 'parallelogram':
          {
            var _shapAdjst2 = getTextByPathList(node, ['p:spPr', 'a:prstGeom', 'a:avLst', 'a:gd', 'attrs', 'fmla']);

            var _adjstVal = 0.25;

            var _maxAdjConst;

            if (w > h) {
              _maxAdjConst = w / h;
            } else {
              _maxAdjConst = h / w;
            }

            if (_shapAdjst2 !== undefined) {
              var _adjst = parseInt(_shapAdjst2.substr(4)) / 100000;

              _adjstVal = _adjst / _maxAdjConst; // console.log("w: "+w+"\nh: "+h+"\nadjst: "+adjstVal+"\nmaxAdjConst: "+maxAdjConst);
            }

            result += ' <polygon points=\'' + _adjstVal * w + ' 0,0 ' + h + ',' + (1 - _adjstVal) * w + ' ' + h + ',' + w + ' 0\' fill=\'' + (!imgFillFlg ? grndFillFlg ? 'url(#linGrd_' + shpId + ')' : fillColor : 'url(#imgPtrn_' + shpId + ')') + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' />';
            break;
          }

        case 'pentagon':
          {
            result += ' <polygon points=\'' + 0.5 * w + ' 0,0 ' + 0.375 * h + ',' + 0.15 * w + ' ' + h + ',' + 0.85 * w + ' ' + h + ',' + w + ' ' + 0.375 * h + '\' fill=\'' + (!imgFillFlg ? grndFillFlg ? 'url(#linGrd_' + shpId + ')' : fillColor : 'url(#imgPtrn_' + shpId + ')') + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' />';
            break;
          }

        case 'hexagon':
          {
            var shapAdjstArray = getTextByPathList(node, ['p:spPr', 'a:prstGeom', 'a:avLst', 'a:gd']);

            var _shapAdjst3;

            for (var i = 0; i < shapAdjstArray.length; i++) {
              if (getTextByPathList(shapAdjstArray[i], ['attrs', 'name']) === 'adj') {
                _shapAdjst3 = getTextByPathList(shapAdjstArray[i], ['attrs', 'fmla']);
              }
            }

            var _adjstVal2 = 0.25;
            var _maxAdjConst2 = 0.62211;

            if (_shapAdjst3 !== undefined) {
              var _adjst2 = parseInt(_shapAdjst3.substr(4)) * 96 / 9144000;

              _adjstVal2 = _adjst2 * 0.5 / _maxAdjConst2; // console.log("w: "+w+"\nh: "+h+"\nadjst: "+adjstVal);
            }

            result += ' <polygon points=\'' + w * _adjstVal2 + ' 0,0 ' + h / 2 + ',' + w * _adjstVal2 + ' ' + h + ',' + (1 - _adjstVal2) * w + ' ' + h + ',' + w + ' ' + h / 2 + ',' + (1 - _adjstVal2) * w + ' 0\' fill=\'' + (!imgFillFlg ? grndFillFlg ? 'url(#linGrd_' + shpId + ')' : fillColor : 'url(#imgPtrn_' + shpId + ')') + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' />';
            break;
          }

        case 'heptagon':
          {
            result += ' <polygon points=\'' + 0.5 * w + ' 0,' + w / 8 + ' ' + h / 4 + ',0 ' + 5 / 8 * h + ',' + w / 4 + ' ' + h + ',' + 3 / 4 * w + ' ' + h + ',' + w + ' ' + 5 / 8 * h + ',' + 7 / 8 * w + ' ' + h / 4 + '\' fill=\'' + (!imgFillFlg ? grndFillFlg ? 'url(#linGrd_' + shpId + ')' : fillColor : 'url(#imgPtrn_' + shpId + ')') + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' />';
            break;
          }

        case 'octagon':
          {
            var _shapAdjst4 = getTextByPathList(node, ['p:spPr', 'a:prstGeom', 'a:avLst', 'a:gd', 'attrs', 'fmla']);

            var adj1 = 0.25;

            if (_shapAdjst4 !== undefined) {
              adj1 = parseInt(_shapAdjst4.substr(4)) / 100000;
            }

            var adj2 = 1 - adj1; // console.log("adj1: "+adj1+"\nadj2: "+adj2);

            result += ' <polygon points=\'' + adj1 * w + ' 0,0 ' + adj1 * h + ',0 ' + adj2 * h + ',' + adj1 * w + ' ' + h + ',' + adj2 * w + ' ' + h + ',' + w + ' ' + adj2 * h + ',' + w + ' ' + adj1 * h + ',' + adj2 * w + ' 0\' fill=\'' + (!imgFillFlg ? grndFillFlg ? 'url(#linGrd_' + shpId + ')' : fillColor : 'url(#imgPtrn_' + shpId + ')') + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' />';
            break;
          }

        case 'decagon':
          {
            result += ' <polygon points=\'' + 3 / 8 * w + ' 0,' + w / 8 + ' ' + h / 8 + ',0 ' + h / 2 + ',' + w / 8 + ' ' + 7 / 8 * h + ',' + 3 / 8 * w + ' ' + h + ',' + 5 / 8 * w + ' ' + h + ',' + 7 / 8 * w + ' ' + 7 / 8 * h + ',' + w + ' ' + h / 2 + ',' + 7 / 8 * w + ' ' + h / 8 + ',' + 5 / 8 * w + ' 0\' fill=\'' + (!imgFillFlg ? grndFillFlg ? 'url(#linGrd_' + shpId + ')' : fillColor : 'url(#imgPtrn_' + shpId + ')') + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' />';
            break;
          }

        case 'dodecagon':
          {
            result += ' <polygon points=\'' + 3 / 8 * w + ' 0,' + w / 8 + ' ' + h / 8 + ',0 ' + 3 / 8 * h + ',0 ' + 5 / 8 * h + ',' + w / 8 + ' ' + 7 / 8 * h + ',' + 3 / 8 * w + ' ' + h + ',' + 5 / 8 * w + ' ' + h + ',' + 7 / 8 * w + ' ' + 7 / 8 * h + ',' + w + ' ' + 5 / 8 * h + ',' + w + ' ' + 3 / 8 * h + ',' + 7 / 8 * w + ' ' + h / 8 + ',' + 5 / 8 * w + ' 0\' fill=\'' + (!imgFillFlg ? grndFillFlg ? 'url(#linGrd_' + shpId + ')' : fillColor : 'url(#imgPtrn_' + shpId + ')') + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' />';
            break;
          }

        case 'bentConnector3':
          {
            var _shapAdjst5 = getTextByPathList(node, ['p:spPr', 'a:prstGeom', 'a:avLst', 'a:gd', 'attrs', 'fmla']); // console.log("isFlipV: "+String(isFlipV)+"\nshapAdjst: "+shapAdjst)


            var _shapAdjstVal = 0.5;

            if (_shapAdjst5 !== undefined) {
              _shapAdjstVal = parseInt(_shapAdjst5.substr(4)) / 100000; // console.log("isFlipV: "+String(isFlipV)+"\nshapAdjst: "+shapAdjst+"\nshapAdjstVal: "+shapAdjstVal);

              if (isFlipV) {
                result += ' <polyline points=\'' + w + ' 0,' + (1 - _shapAdjstVal) * w + ' 0,' + (1 - _shapAdjstVal) * w + ' ' + h + ',0 ' + h + '\' fill=\'transparent\'' + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' ';
              } else {
                result += ' <polyline points=\'0 0,' + _shapAdjstVal * w + ' 0,' + _shapAdjstVal * w + ' ' + h + ',' + w + ' ' + h + '\' fill=\'transparent\'' + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' ';
              }

              if (headEndNodeAttrs !== undefined && (headEndNodeAttrs['type'] === 'triangle' || headEndNodeAttrs['type'] === 'arrow')) {
                result += 'marker-start=\'url(#markerTriangle_' + shpId + ')\' ';
              }

              if (tailEndNodeAttrs !== undefined && (tailEndNodeAttrs['type'] === 'triangle' || tailEndNodeAttrs['type'] === 'arrow')) {
                result += 'marker-end=\'url(#markerTriangle_' + shpId + ')\' ';
              }

              result += '/>';
            }

            break;
          }

        case 'plus':
          {
            var _shapAdjst6 = getTextByPathList(node, ['p:spPr', 'a:prstGeom', 'a:avLst', 'a:gd', 'attrs', 'fmla']);

            var _adj = 0.25;

            if (_shapAdjst6 !== undefined) {
              _adj = parseInt(_shapAdjst6.substr(4)) / 100000;
            }

            var _adj2 = 1 - _adj;

            result += ' <polygon points=\'' + _adj * w + ' 0,' + _adj * w + ' ' + _adj * h + ',0 ' + _adj * h + ',0 ' + _adj2 * h + ',' + _adj * w + ' ' + _adj2 * h + ',' + _adj * w + ' ' + h + ',' + _adj2 * w + ' ' + h + ',' + _adj2 * w + ' ' + _adj2 * h + ',' + w + ' ' + _adj2 * h + ',' + +w + ' ' + _adj * h + ',' + _adj2 * w + ' ' + _adj * h + ',' + _adj2 * w + ' 0\' fill=\'' + (!imgFillFlg ? grndFillFlg ? 'url(#linGrd_' + shpId + ')' : fillColor : 'url(#imgPtrn_' + shpId + ')') + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' />'; // console.log((!imgFillFlg?(grndFillFlg?"url(#linGrd_"+shpId+")":fillColor):"url(#imgPtrn_"+shpId+")"))

            break;
          }

        case 'line':
        case 'straightConnector1':
        case 'bentConnector4':
        case 'bentConnector5':
        case 'curvedConnector2':
        case 'curvedConnector3':
        case 'curvedConnector4':
        case 'curvedConnector5':
          {
            if (isFlipV) {
              result += '<line x1=\'' + w + '\' y1=\'0\' x2=\'0\' y2=\'' + h + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' ';
            } else {
              result += '<line x1=\'0\' y1=\'0\' x2=\'' + w + '\' y2=\'' + h + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' ';
            }

            if (headEndNodeAttrs !== undefined && (headEndNodeAttrs['type'] === 'triangle' || headEndNodeAttrs['type'] === 'arrow')) {
              result += 'marker-start=\'url(#markerTriangle_' + shpId + ')\' ';
            }

            if (tailEndNodeAttrs !== undefined && (tailEndNodeAttrs['type'] === 'triangle' || tailEndNodeAttrs['type'] === 'arrow')) {
              result += 'marker-end=\'url(#markerTriangle_' + shpId + ')\' ';
            }

            result += '/>';
            break;
          }

        case 'rightArrow':
          {
            var _shapAdjstArray = getTextByPathList(node, ['p:spPr', 'a:prstGeom', 'a:avLst', 'a:gd']);

            var sAdj1;
            var sAdj1Val = 0.5;
            var sAdj2;
            var sAdj2Val = 0.5;
            var maxSAdj2Const = w / h;

            if (_shapAdjstArray !== undefined) {
              for (var _i4 = 0; _i4 < _shapAdjstArray.length; _i4++) {
                var sAdjName = getTextByPathList(_shapAdjstArray[_i4], ['attrs', 'name']);

                if (sAdjName === 'adj1') {
                  sAdj1 = getTextByPathList(_shapAdjstArray[_i4], ['attrs', 'fmla']);
                  sAdj1Val = 0.5 - parseInt(sAdj1.substr(4)) / 200000;
                } else if (sAdjName === 'adj2') {
                  sAdj2 = getTextByPathList(_shapAdjstArray[_i4], ['attrs', 'fmla']);
                  var sAdj2Val2 = parseInt(sAdj2.substr(4)) / 100000;
                  sAdj2Val = 1 - sAdj2Val2 / maxSAdj2Const;
                }
              }
            } // console.log("w: "+w+"\nh: "+h+"\nsAdj1: "+sAdj1Val+"\nsAdj2: "+sAdj2Val);


            result += ' <polygon points=\'' + w + ' ' + h / 2 + ',' + sAdj2Val * w + ' 0,' + sAdj2Val * w + ' ' + sAdj1Val * h + ',0 ' + sAdj1Val * h + ',0 ' + (1 - sAdj1Val) * h + ',' + sAdj2Val * w + ' ' + (1 - sAdj1Val) * h + ', ' + sAdj2Val * w + ' ' + h + '\' fill=\'' + (!imgFillFlg ? grndFillFlg ? 'url(#linGrd_' + shpId + ')' : fillColor : 'url(#imgPtrn_' + shpId + ')') + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' />';
            break;
          }

        case 'leftArrow':
          {
            var _shapAdjstArray2 = getTextByPathList(node, ['p:spPr', 'a:prstGeom', 'a:avLst', 'a:gd']);

            var _sAdj;

            var _sAdj1Val = 0.5;

            var _sAdj2;

            var _sAdj2Val = 0.5;

            var _maxSAdj2Const = w / h;

            if (_shapAdjstArray2 !== undefined) {
              for (var _i5 = 0; _i5 < _shapAdjstArray2.length; _i5++) {
                var _sAdjName = getTextByPathList(_shapAdjstArray2[_i5], ['attrs', 'name']);

                if (_sAdjName === 'adj1') {
                  _sAdj = getTextByPathList(_shapAdjstArray2[_i5], ['attrs', 'fmla']);
                  _sAdj1Val = 0.5 - parseInt(_sAdj.substr(4)) / 200000;
                } else if (_sAdjName === 'adj2') {
                  _sAdj2 = getTextByPathList(_shapAdjstArray2[_i5], ['attrs', 'fmla']);

                  var _sAdj2Val2 = parseInt(_sAdj2.substr(4)) / 100000;

                  _sAdj2Val = _sAdj2Val2 / _maxSAdj2Const;
                }
              }
            } // console.log("w: "+w+"\nh: "+h+"\nsAdj1: "+sAdj1Val+"\nsAdj2: "+sAdj2Val);


            result += ' <polygon points=\'0 ' + h / 2 + ',' + _sAdj2Val * w + ' ' + h + ',' + _sAdj2Val * w + ' ' + (1 - _sAdj1Val) * h + ',' + w + ' ' + (1 - _sAdj1Val) * h + ',' + w + ' ' + _sAdj1Val * h + ',' + _sAdj2Val * w + ' ' + _sAdj1Val * h + ', ' + _sAdj2Val * w + ' 0\' fill=\'' + (!imgFillFlg ? grndFillFlg ? 'url(#linGrd_' + shpId + ')' : fillColor : 'url(#imgPtrn_' + shpId + ')') + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' />';
            break;
          }

        case 'downArrow':
          {
            var _shapAdjstArray3 = getTextByPathList(node, ['p:spPr', 'a:prstGeom', 'a:avLst', 'a:gd']);

            var _sAdj3;

            var _sAdj1Val2 = 0.5;

            var _sAdj4;

            var _sAdj2Val3 = 0.5;

            var _maxSAdj2Const2 = h / w;

            if (_shapAdjstArray3 !== undefined) {
              for (var _i6 = 0; _i6 < _shapAdjstArray3.length; _i6++) {
                var _sAdjName2 = getTextByPathList(_shapAdjstArray3[_i6], ['attrs', 'name']);

                if (_sAdjName2 === 'adj1') {
                  _sAdj3 = getTextByPathList(_shapAdjstArray3[_i6], ['attrs', 'fmla']);
                  _sAdj1Val2 = parseInt(_sAdj3.substr(4)) / 200000;
                } else if (_sAdjName2 === 'adj2') {
                  _sAdj4 = getTextByPathList(_shapAdjstArray3[_i6], ['attrs', 'fmla']);

                  var _sAdj2Val4 = parseInt(_sAdj4.substr(4)) / 100000;

                  _sAdj2Val3 = _sAdj2Val4 / _maxSAdj2Const2;
                }
              }
            } // console.log("w: "+w+"\nh: "+h+"\nsAdj1: "+sAdj1Val+"\nsAdj2: "+sAdj2Val);


            result += ' <polygon points=\'' + (0.5 - _sAdj1Val2) * w + ' 0,' + (0.5 - _sAdj1Val2) * w + ' ' + (1 - _sAdj2Val3) * h + ',0 ' + (1 - _sAdj2Val3) * h + ',' + w / 2 + ' ' + h + ',' + w + ' ' + (1 - _sAdj2Val3) * h + ',' + (0.5 + _sAdj1Val2) * w + ' ' + (1 - _sAdj2Val3) * h + ', ' + (0.5 + _sAdj1Val2) * w + ' 0\' fill=\'' + (!imgFillFlg ? grndFillFlg ? 'url(#linGrd_' + shpId + ')' : fillColor : 'url(#imgPtrn_' + shpId + ')') + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' />';
            break;
          }

        case 'upArrow':
          {
            var _shapAdjstArray4 = getTextByPathList(node, ['p:spPr', 'a:prstGeom', 'a:avLst', 'a:gd']);

            var _sAdj5;

            var _sAdj1Val3 = 0.5;

            var _sAdj6;

            var _sAdj2Val5 = 0.5;

            var _maxSAdj2Const3 = h / w;

            if (_shapAdjstArray4 !== undefined) {
              for (var _i7 = 0; _i7 < _shapAdjstArray4.length; _i7++) {
                var _sAdjName3 = getTextByPathList(_shapAdjstArray4[_i7], ['attrs', 'name']);

                if (_sAdjName3 === 'adj1') {
                  _sAdj5 = getTextByPathList(_shapAdjstArray4[_i7], ['attrs', 'fmla']);
                  _sAdj1Val3 = parseInt(_sAdj5.substr(4)) / 200000;
                } else if (_sAdjName3 === 'adj2') {
                  _sAdj6 = getTextByPathList(_shapAdjstArray4[_i7], ['attrs', 'fmla']);

                  var _sAdj2Val6 = parseInt(_sAdj6.substr(4)) / 100000;

                  _sAdj2Val5 = _sAdj2Val6 / _maxSAdj2Const3;
                }
              }
            }

            result += ' <polygon points=\'' + w / 2 + ' 0,0 ' + _sAdj2Val5 * h + ',' + (0.5 - _sAdj1Val3) * w + ' ' + _sAdj2Val5 * h + ',' + (0.5 - _sAdj1Val3) * w + ' ' + h + ',' + (0.5 + _sAdj1Val3) * w + ' ' + h + ',' + (0.5 + _sAdj1Val3) * w + ' ' + _sAdj2Val5 * h + ', ' + w + ' ' + _sAdj2Val5 * h + '\' fill=\'' + (!imgFillFlg ? grndFillFlg ? 'url(#linGrd_' + shpId + ')' : fillColor : 'url(#imgPtrn_' + shpId + ')') + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' />';
            break;
          }

        case 'leftRightArrow':
          {
            var _shapAdjstArray5 = getTextByPathList(node, ['p:spPr', 'a:prstGeom', 'a:avLst', 'a:gd']);

            var _sAdj7;

            var _sAdj1Val4 = 0.5;

            var _sAdj8;

            var _sAdj2Val7 = 0.5;

            var _maxSAdj2Const4 = w / h;

            if (_shapAdjstArray5 !== undefined) {
              for (var _i8 = 0; _i8 < _shapAdjstArray5.length; _i8++) {
                var _sAdjName4 = getTextByPathList(_shapAdjstArray5[_i8], ['attrs', 'name']);

                if (_sAdjName4 === 'adj1') {
                  _sAdj7 = getTextByPathList(_shapAdjstArray5[_i8], ['attrs', 'fmla']);
                  _sAdj1Val4 = 0.5 - parseInt(_sAdj7.substr(4)) / 200000;
                } else if (_sAdjName4 === 'adj2') {
                  _sAdj8 = getTextByPathList(_shapAdjstArray5[_i8], ['attrs', 'fmla']);

                  var _sAdj2Val8 = parseInt(_sAdj8.substr(4)) / 100000;

                  _sAdj2Val7 = _sAdj2Val8 / _maxSAdj2Const4;
                }
              }
            } // console.log("w: "+w+"\nh: "+h+"\nsAdj1: "+sAdj1Val+"\nsAdj2: "+sAdj2Val);


            result += ' <polygon points=\'0 ' + h / 2 + ',' + _sAdj2Val7 * w + ' ' + h + ',' + _sAdj2Val7 * w + ' ' + (1 - _sAdj1Val4) * h + ',' + (1 - _sAdj2Val7) * w + ' ' + (1 - _sAdj1Val4) * h + ',' + (1 - _sAdj2Val7) * w + ' ' + h + ',' + w + ' ' + h / 2 + ', ' + (1 - _sAdj2Val7) * w + ' 0,' + (1 - _sAdj2Val7) * w + ' ' + _sAdj1Val4 * h + ',' + _sAdj2Val7 * w + ' ' + _sAdj1Val4 * h + ',' + _sAdj2Val7 * w + ' 0\' fill=\'' + (!imgFillFlg ? grndFillFlg ? 'url(#linGrd_' + shpId + ')' : fillColor : 'url(#imgPtrn_' + shpId + ')') + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' />';
            break;
          }

        case 'upDownArrow':
          {
            var _shapAdjstArray6 = getTextByPathList(node, ['p:spPr', 'a:prstGeom', 'a:avLst', 'a:gd']);

            var _sAdj9;

            var _sAdj1Val5 = 0.5;

            var _sAdj10;

            var _sAdj2Val9 = 0.5;

            var _maxSAdj2Const5 = h / w;

            if (_shapAdjstArray6 !== undefined) {
              for (var _i9 = 0; _i9 < _shapAdjstArray6.length; _i9++) {
                var _sAdjName5 = getTextByPathList(_shapAdjstArray6[_i9], ['attrs', 'name']);

                if (_sAdjName5 === 'adj1') {
                  _sAdj9 = getTextByPathList(_shapAdjstArray6[_i9], ['attrs', 'fmla']);
                  _sAdj1Val5 = 0.5 - parseInt(_sAdj9.substr(4)) / 200000;
                } else if (_sAdjName5 === 'adj2') {
                  _sAdj10 = getTextByPathList(_shapAdjstArray6[_i9], ['attrs', 'fmla']);

                  var _sAdj2Val10 = parseInt(_sAdj10.substr(4)) / 100000;

                  _sAdj2Val9 = _sAdj2Val10 / _maxSAdj2Const5;
                }
              }
            } // console.log("w: "+w+"\nh: "+h+"\nsAdj1: "+sAdj1Val+"\nsAdj2: "+sAdj2Val);


            result += ' <polygon points=\'' + w / 2 + ' 0,0 ' + _sAdj2Val9 * h + ',' + _sAdj1Val5 * w + ' ' + _sAdj2Val9 * h + ',' + _sAdj1Val5 * w + ' ' + (1 - _sAdj2Val9) * h + ',0 ' + (1 - _sAdj2Val9) * h + ',' + w / 2 + ' ' + h + ', ' + w + ' ' + (1 - _sAdj2Val9) * h + ',' + (1 - _sAdj1Val5) * w + ' ' + (1 - _sAdj2Val9) * h + ',' + (1 - _sAdj1Val5) * w + ' ' + _sAdj2Val9 * h + ',' + w + ' ' + _sAdj2Val9 * h + '\' fill=\'' + (!imgFillFlg ? grndFillFlg ? 'url(#linGrd_' + shpId + ')' : fillColor : 'url(#imgPtrn_' + shpId + ')') + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' />';
            break;
          }

        case 'bentArrow':
        case 'bentUpArrow':
        case 'stripedRightArrow':
        case 'quadArrow':
        case 'circularArrow':
        case 'swooshArrow':
        case 'leftRightUpArrow':
        case 'leftUpArrow':
        case 'leftCircularArrow':
        case 'notchedRightArrow':
        case 'curvedDownArrow':
        case 'curvedLeftArrow':
        case 'curvedRightArrow':
        case 'curvedUpArrow':
        case 'uturnArrow':
        case 'leftRightCircularArrow':
          break;

        case undefined:
        default:
          console.warn('Undefine shape type.');
      }

      result += '</svg>';
      result += '<div class=\'block content ' + getVerticalAlign(node, slideLayoutSpNode, slideMasterSpNode, type) + '\' _id=\'' + id + '\' _idx=\'' + idx + '\' _type=\'' + type + '\' Name=\'' + name + '\' style=\'' + getPosition(slideXfrmNode, slideLayoutXfrmNode, slideMasterXfrmNode) + getSize(slideXfrmNode, slideLayoutXfrmNode, slideMasterXfrmNode) + ' z-index: ' + order + ';' + 'transform: rotate(' + rotate + 'deg);' + '\'>'; // TextBody

      if (node['p:txBody'] !== undefined) {
        result += genTextBody(node['p:txBody'], slideLayoutSpNode, slideMasterSpNode, type, warpObj);
      }

      result += '</div>';
    } else if (custShapType !== undefined) {
      // custGeom here - Amir ///////////////////////////////////////////////////////
      // http://officeopenxml.com/drwSp-custGeom.php
      var pathLstNode = getTextByPathList(custShapType, ['a:pathLst']); // const pathNode = getTextByPathList(pathLstNode, ['a:path', 'attrs'])
      // const maxX = parseInt(pathNode['w']) * 96 / 914400
      // const maxY = parseInt(pathNode['h']) * 96 / 914400
      // console.log("w = "+w+"\nh = "+h+"\nmaxX = "+maxX +"\nmaxY = " + maxY);
      // cheke if it is close shape

      var closeNode = getTextByPathList(pathLstNode, ['a:path', 'a:close']);
      var startPoint = getTextByPathList(pathLstNode, ['a:path', 'a:moveTo', 'a:pt', 'attrs']);
      var spX = parseInt(startPoint['x']) * 96 / 914400;
      var spY = parseInt(startPoint['y']) * 96 / 914400;

      var _d = 'M' + spX + ',' + spY;

      var pathNodes = getTextByPathList(pathLstNode, ['a:path']);
      var lnToNodes = pathNodes['a:lnTo'];
      var cubicBezToNodes = pathNodes['a:cubicBezTo'];
      var sortblAry = [];

      if (lnToNodes !== undefined) {
        Object.keys(lnToNodes).forEach(function (key) {
          var lnToPtNode = lnToNodes[key]['a:pt'];

          if (lnToPtNode !== undefined) {
            Object.keys(lnToPtNode).forEach(function (key2) {
              var ptObj = {};
              var lnToNoPt = lnToPtNode[key2];
              var ptX = lnToNoPt['x'];
              var ptY = lnToNoPt['y'];
              var ptOrdr = lnToNoPt['order'];
              ptObj.type = 'lnto';
              ptObj.order = ptOrdr;
              ptObj.x = ptX;
              ptObj.y = ptY;
              sortblAry.push(ptObj); // console.log(key2, lnToNoPt);
            });
          }
        });
      }

      if (cubicBezToNodes !== undefined) {
        Object.keys(cubicBezToNodes).forEach(function (key) {
          // console.log("cubicBezTo["+key+"]:");
          var cubicBezToPtNodes = cubicBezToNodes[key]['a:pt'];

          if (cubicBezToPtNodes !== undefined) {
            Object.keys(cubicBezToPtNodes).forEach(function (key2) {
              // console.log("cubicBezTo["+key+"]pt["+key2+"]:");
              var cubBzPts = cubicBezToPtNodes[key2];
              Object.keys(cubBzPts).forEach(function (key3) {
                // console.log(key3, cubBzPts[key3]);
                var ptObj = {};
                var cubBzPt = cubBzPts[key3];
                var ptX = cubBzPt['x'];
                var ptY = cubBzPt['y'];
                var ptOrdr = cubBzPt['order'];
                ptObj.type = 'cubicBezTo';
                ptObj.order = ptOrdr;
                ptObj.x = ptX;
                ptObj.y = ptY;
                sortblAry.push(ptObj);
              });
            });
          }
        });
      }

      var sortByOrder = sortblAry.slice(0);
      sortByOrder.sort(function (a, b) {
        return a.order - b.order;
      }); // console.log(sortByOrder);

      var k = 0;

      while (k < sortByOrder.length) {
        if (sortByOrder[k].type === 'lnto') {
          var Lx = parseInt(sortByOrder[k].x) * 96 / 914400;
          var Ly = parseInt(sortByOrder[k].y) * 96 / 914400;
          _d += 'L' + Lx + ',' + Ly;
          k++;
        } else {
          // "cubicBezTo"
          var Cx1 = parseInt(sortByOrder[k].x) * 96 / 914400;
          var Cy1 = parseInt(sortByOrder[k].y) * 96 / 914400;
          var Cx2 = parseInt(sortByOrder[k + 1].x) * 96 / 914400;
          var Cy2 = parseInt(sortByOrder[k + 1].y) * 96 / 914400;
          var Cx3 = parseInt(sortByOrder[k + 2].x) * 96 / 914400;
          var Cy3 = parseInt(sortByOrder[k + 2].y) * 96 / 914400;
          _d += 'C' + Cx1 + ',' + Cy1 + ' ' + Cx2 + ',' + Cy2 + ' ' + Cx3 + ',' + Cy3;
          k += 3;
        }
      }

      result += '<path d=\'' + _d + '\' fill=\'' + (!imgFillFlg ? grndFillFlg ? 'url(#linGrd_' + shpId + ')' : fillColor : 'url(#imgPtrn_' + shpId + ')') + '\' stroke=\'' + border.color + '\' stroke-width=\'' + border.width + '\' stroke-dasharray=\'' + border.strokeDasharray + '\' ';

      if (closeNode !== undefined) {
        // console.log("Close shape");
        result += '/>';
      } else {
        // console.log("Open shape");
        // check and add "marker-start" and "marker-end"
        if (headEndNodeAttrs !== undefined && (headEndNodeAttrs['type'] === 'triangle' || headEndNodeAttrs['type'] === 'arrow')) {
          result += 'marker-start=\'url(#markerTriangle_' + shpId + ')\' ';
        }

        if (tailEndNodeAttrs !== undefined && (tailEndNodeAttrs['type'] === 'triangle' || tailEndNodeAttrs['type'] === 'arrow')) {
          result += 'marker-end=\'url(#markerTriangle_' + shpId + ')\' ';
        }

        result += '/>';
      }

      result += '</svg>';
      result += '<div class=\'block content ' + getVerticalAlign(node, slideLayoutSpNode, slideMasterSpNode, type) + '\' _id=\'' + id + '\' _idx=\'' + idx + '\' _type=\'' + type + '\' Name=\'' + name + '\' style=\'' + getPosition(slideXfrmNode, slideLayoutXfrmNode, slideMasterXfrmNode) + getSize(slideXfrmNode, slideLayoutXfrmNode, slideMasterXfrmNode) + ' z-index: ' + order + ';' + 'transform: rotate(' + rotate + 'deg);' + '\'>'; // TextBody

      if (node['p:txBody'] !== undefined) {
        result += genTextBody(node['p:txBody'], slideLayoutSpNode, slideMasterSpNode, type, warpObj);
      }

      result += '</div>'; // result = "";
    } else {
      result += '<div class=\'block content ' + getVerticalAlign(node, slideLayoutSpNode, slideMasterSpNode, type) + '\' _id=\'' + id + '\' _idx=\'' + idx + '\' _type=\'' + type + '\' Name=\'' + name + '\' style=\'' + getPosition(slideXfrmNode, slideLayoutXfrmNode, slideMasterXfrmNode) + getSize(slideXfrmNode, slideLayoutXfrmNode, slideMasterXfrmNode) + getBorder(node, false) + getShapeFill(node, false, warpObj) + ' z-index: ' + order + ';' + 'transform: rotate(' + rotate + 'deg);' + '\'>'; // TextBody

      if (node['p:txBody'] !== undefined) {
        result += genTextBody(node['p:txBody'], slideLayoutSpNode, slideMasterSpNode, type, warpObj);
      }

      result += '</div>';
    }

    return result;
  }

  function processPicNode(node, warpObj) {
    var order = node['attrs']['order'];
    var rid = node['p:blipFill']['a:blip']['attrs']['r:embed'];
    var imgName = warpObj['slideResObj'][rid]['target'];
    var imgFileExt = extractFileExtension(imgName).toLowerCase();
    var zip = warpObj['zip'];
    var imgArrayBuffer = zip.file(imgName).asArrayBuffer();
    var mimeType = '';
    var xfrmNode = node['p:spPr']['a:xfrm']; // /////////////////////////////////////Amir//////////////////////////////

    var rotate = angleToDegrees(node['p:spPr']['a:xfrm']['attrs']['rot']); // ////////////////////////////////////////////////////////////////////////

    mimeType = getImageMimeType(imgFileExt);
    return '<div class=\'block content\' style=\'' + getPosition(xfrmNode, undefined, undefined) + getSize(xfrmNode, undefined, undefined) + ' z-index: ' + order + ';' + 'transform: rotate(' + rotate + 'deg);' + '\'><img src=\'data:' + mimeType + ';base64,' + base64ArrayBuffer(imgArrayBuffer) + '\' style=\'width: 100%; height: 100%\'/></div>';
  }

  function genTextBody(textBodyNode, slideLayoutSpNode, slideMasterSpNode, type, warpObj) {
    var text = '';
    var slideMasterTextStyles = warpObj['slideMasterTextStyles'];

    if (textBodyNode === undefined) {
      return text;
    } // rtl : <p:txBody>
    //          <a:bodyPr wrap="square" rtlCol="1">
    // const rtlStr = "";


    var pNode;
    var rNode;

    if (textBodyNode['a:p'].constructor === Array) {
      // multi p
      for (var i = 0; i < textBodyNode['a:p'].length; i++) {
        pNode = textBodyNode['a:p'][i];
        rNode = pNode['a:r']; // const isRTL = getTextDirection(pNode, type, slideMasterTextStyles);
        // rtlStr = "";//"dir='"+isRTL+"'";

        text += '<div  class=\'' + getHorizontalAlign(pNode, slideLayoutSpNode, slideMasterSpNode, type, slideMasterTextStyles) + '\'>';
        text += genBuChar(pNode, slideLayoutSpNode, slideMasterSpNode, type, warpObj);

        if (rNode === undefined) {
          // without r
          text += genSpanElement(pNode, slideLayoutSpNode, slideMasterSpNode, type, warpObj);
        } else if (rNode.constructor === Array) {
          // with multi r
          for (var j = 0; j < rNode.length; j++) {
            text += genSpanElement(rNode[j], slideLayoutSpNode, slideMasterSpNode, type, warpObj); // ////////////////Amir////////////

            if (pNode['a:br'] !== undefined) {
              text += '<br>';
            } // ////////////////////////////////

          }
        } else {
          // with one r
          text += genSpanElement(rNode, slideLayoutSpNode, slideMasterSpNode, type, warpObj);
        }

        text += '</div>';
      }
    } else {
      // one p
      pNode = textBodyNode['a:p'];
      rNode = pNode['a:r']; // const isRTL = getTextDirection(pNode, type, slideMasterTextStyles);
      // rtlStr = "";//"dir='"+isRTL+"'";

      text += '<div class=\'slide-prgrph ' + getHorizontalAlign(pNode, slideLayoutSpNode, slideMasterSpNode, type, slideMasterTextStyles) + '\'>';
      text += genBuChar(pNode, slideLayoutSpNode, slideMasterSpNode, type, warpObj);

      if (rNode === undefined) {
        // without r
        text += genSpanElement(pNode, slideLayoutSpNode, slideMasterSpNode, type, warpObj);
      } else if (rNode.constructor === Array) {
        // with multi r
        for (var _j = 0; _j < rNode.length; _j++) {
          text += genSpanElement(rNode[_j], slideLayoutSpNode, slideMasterSpNode, type, warpObj); // ////////////////Amir////////////

          if (pNode['a:br'] !== undefined) {
            text += '<br>';
          } // ////////////////////////////////

        }
      } else {
        // with one r
        text += genSpanElement(rNode, slideLayoutSpNode, slideMasterSpNode, type, warpObj);
      }

      text += '</div>';
    }

    return text;
  }

  function genBuChar(node, slideLayoutSpNode, slideMasterSpNode, type, warpObj) {
    // /////////////////////////////////////Amir///////////////////////////////
    var sldMstrTxtStyles = warpObj['slideMasterTextStyles'];
    var rNode = node['a:r'];
    var dfltBultColor, dfltBultSize, bultColor, bultSize;

    if (rNode !== undefined) {
      dfltBultColor = getFontColor(rNode, type, sldMstrTxtStyles);
      dfltBultSize = getFontSize(rNode, slideLayoutSpNode, slideMasterSpNode, type, sldMstrTxtStyles);
    } else {
      dfltBultColor = getFontColor(node, type, sldMstrTxtStyles);
      dfltBultSize = getFontSize(node, slideLayoutSpNode, slideMasterSpNode, type, sldMstrTxtStyles);
    } // console.log("Bullet Size: " + bultSize);


    var bullet = ''; // ///////////////////////////////////////////////////////////////

    var pPrNode = node['a:pPr']; // ////////////////cheke if is rtl ///Amir ////////////////////////////////////

    var getRtlVal = getTextByPathList(pPrNode, ['attrs', 'rtl']);
    var isRTL = false;

    if (getRtlVal !== undefined && getRtlVal === '1') {
      isRTL = true;
    } // //////////////////////////////////////////////////////////


    var lvl = parseInt(getTextByPathList(pPrNode, ['attrs', 'lvl']));

    if (isNaN(lvl)) {
      lvl = 0;
    }

    var buChar = getTextByPathList(pPrNode, ['a:buChar', 'attrs', 'char']); // ///////////////////////////////Amir///////////////////////////////////

    var buType = 'TYPE_NONE';
    var buNum = getTextByPathList(pPrNode, ['a:buAutoNum', 'attrs', 'type']);
    var buPic = getTextByPathList(pPrNode, ['a:buBlip']);

    if (buChar !== undefined) {
      buType = 'TYPE_BULLET'; // console.log("Bullet Chr to code: " + buChar.charCodeAt(0));
    }

    if (buNum !== undefined) {
      buType = 'TYPE_NUMERIC';
    }

    if (buPic !== undefined) {
      buType = 'TYPE_BULPIC';
    }

    var buFontAttrs;

    if (buType !== 'TYPE_NONE') {
      buFontAttrs = getTextByPathList(pPrNode, ['a:buFont', 'attrs']);
    } // console.log("Bullet Type: " + buType);
    // console.log("NumericTypr: " + buNum);
    // console.log("buChar: " + (buChar === undefined?'':buChar.charCodeAt(0)));
    // get definde bullet COLOR


    var defBultColor = 'NoNe';

    if (pPrNode) {
      var buClrNode = pPrNode['a:buClr'];

      if (buClrNode !== undefined) {
        defBultColor = getSolidFill(buClrNode);
      } else {// console.log("buClrNode: " + buClrNode);
      }
    }

    if (defBultColor === 'NoNe') {
      bultColor = dfltBultColor;
    } else {
      bultColor = '#' + defBultColor;
    } // get definde bullet SIZE


    var buFontSize;
    buFontSize = getTextByPathList(pPrNode, ['a:buSzPts', 'attrs', 'val']); // pt

    if (buFontSize !== undefined) {
      bultSize = parseInt(buFontSize) / 100 + 'pt';
    } else {
      buFontSize = getTextByPathList(pPrNode, ['a:buSzPct', 'attrs', 'val']);

      if (buFontSize !== undefined) {
        var prcnt = parseInt(buFontSize) / 100000; // dfltBultSize = XXpt

        var dfltBultSizeNoPt = dfltBultSize.substr(0, dfltBultSize.length - 2);
        bultSize = prcnt * parseInt(dfltBultSizeNoPt) + 'pt';
      } else {
        bultSize = dfltBultSize;
      }
    } // //////////////////////////////////////////////////////////////////////


    var marginLeft;
    var marginRight;

    if (buType === 'TYPE_BULLET') {
      // const buFontAttrs = getTextByPathList(pPrNode, ["a:buFont", "attrs"]);
      if (buFontAttrs !== undefined) {
        marginLeft = parseInt(getTextByPathList(pPrNode, ['attrs', 'marL'])) * 96 / 914400;
        marginRight = parseInt(buFontAttrs['pitchFamily']);

        if (isNaN(marginLeft)) {
          marginLeft = 328600 * 96 / 914400;
        }

        if (isNaN(marginRight)) {
          marginRight = 0;
        }

        var typeface = buFontAttrs['typeface'];
        bullet = '<span style=\'font-family: ' + typeface + '; margin-left: ' + marginLeft * lvl + 'px' + '; margin-right: ' + marginRight + 'px' + ';color:' + bultColor + ';font-size:' + bultSize + ';';

        if (isRTL) {
          bullet += ' float: right;  direction:rtl';
        }

        bullet += '\'>' + buChar + '</span>';
      } else {
        marginLeft = 328600 * 96 / 914400 * lvl;
        bullet = '<span style=\'margin-left: ' + marginLeft + 'px;\'>' + buChar + '</span>';
      }
    } else if (buType === 'TYPE_NUMERIC') {
      // /////////Amir///////////////////////////////
      if (buFontAttrs !== undefined) {
        marginLeft = parseInt(getTextByPathList(pPrNode, ['attrs', 'marL'])) * 96 / 914400;
        marginRight = parseInt(buFontAttrs['pitchFamily']);

        if (isNaN(marginLeft)) {
          marginLeft = 328600 * 96 / 914400;
        }

        if (isNaN(marginRight)) {
          marginRight = 0;
        } // const typeface = buFontAttrs["typeface"];


        bullet = '<span style=\'margin-left: ' + marginLeft * lvl + 'px' + '; margin-right: ' + marginRight + 'px' + ';color:' + bultColor + ';font-size:' + bultSize + ';';

        if (isRTL) {
          bullet += ' float: right; direction:rtl;';
        } else {
          bullet += ' float: left; direction:ltr;';
        }

        bullet += '\' data-bulltname = \'' + buNum + '\' data-bulltlvl = \'' + lvl + '\' class=\'numeric-bullet-style\'></span>';
      } else {
        marginLeft = 328600 * 96 / 914400 * lvl;
        bullet = '<span style=\'margin-left: ' + marginLeft + 'px;';

        if (isRTL) {
          bullet += ' float: right; direction:rtl;';
        } else {
          bullet += ' float: left; direction:ltr;';
        }

        bullet += '\' data-bulltname = \'' + buNum + '\' data-bulltlvl = \'' + lvl + '\' class=\'numeric-bullet-style\'></span>';
      }
    } else if (buType === 'TYPE_BULPIC') {
      // PIC BULLET
      marginLeft = parseInt(getTextByPathList(pPrNode, ['attrs', 'marL'])) * 96 / 914400;
      marginRight = parseInt(getTextByPathList(pPrNode, ['attrs', 'marR'])) * 96 / 914400;

      if (isNaN(marginRight)) {
        marginRight = 0;
      } // console.log("marginRight: "+marginRight)
      // buPic


      if (isNaN(marginLeft)) {
        marginLeft = 328600 * 96 / 914400;
      } else {
        marginLeft = 0;
      } // const buPicId = getTextByPathList(buPic, ["a:blip","a:extLst","a:ext","asvg:svgBlip" , "attrs", "r:embed"]);


      var buPicId = getTextByPathList(buPic, ['a:blip', 'attrs', 'r:embed']); // const svgPicPath = ''

      var buImg;

      if (buPicId !== undefined) {
        // svgPicPath = warpObj["slideResObj"][buPicId]["target"];
        // buImg = warpObj["zip"].file(svgPicPath).asText();
        // }else{
        // buPicId = getTextByPathList(buPic, ["a:blip", "attrs", "r:embed"]);
        var imgPath = warpObj['slideResObj'][buPicId]['target'];
        var imgArrayBuffer = warpObj['zip'].file(imgPath).asArrayBuffer();
        var imgExt = imgPath.split('.').pop();
        var imgMimeType = getImageMimeType(imgExt);
        buImg = '<img src=\'data:' + imgMimeType + ';base64,' + base64ArrayBuffer(imgArrayBuffer) + '\' style=\'width: 100%; height: 100%\'/>'; // console.log("imgPath: "+imgPath+"\nimgMimeType: "+imgMimeType)
      }

      if (buPicId === undefined) {
        buImg = '&#8227;';
      }

      bullet = '<span style=\'margin-left: ' + marginLeft * lvl + 'px' + '; margin-right: ' + marginRight + 'px' + ';width:' + bultSize + ';display: inline-block; ';

      if (isRTL) {
        bullet += ' float: right;direction:rtl';
      }

      bullet += '\'>' + buImg + '  </span>'; // ////////////////////////////////////////////////////////////////////////////////////
    } else {
      bullet = '<span style=\'margin-left: ' + 328600 * 96 / 914400 * lvl + 'px' + '; margin-right: ' + 0 + 'px;\'></span>';
    }

    return bullet;
  }

  function genSpanElement(node, slideLayoutSpNode, slideMasterSpNode, type, warpObj) {
    var slideMasterTextStyles = warpObj['slideMasterTextStyles'];
    var text = node['a:t'];

    if (typeof text !== 'string' && !(text instanceof String)) {
      text = getTextByPathList(node, ['a:fld', 'a:t']);

      if (typeof text !== 'string' && !(text instanceof String)) {
        text = '&nbsp;';
      }
    }

    var styleText = 'color:' + getFontColor(node, type, slideMasterTextStyles) + ';font-size:' + getFontSize(node, slideLayoutSpNode, slideMasterSpNode, type, slideMasterTextStyles) + ';font-family:' + getFontType(node, type, slideMasterTextStyles) + ';font-weight:' + getFontBold(node, type, slideMasterTextStyles) + ';font-style:' + getFontItalic(node, type, slideMasterTextStyles) + ';text-decoration:' + getFontDecoration(node, type, slideMasterTextStyles) + ';text-align:' + getTextHorizontalAlign(node, type, slideMasterTextStyles) + ';vertical-align:' + getTextVerticalAlign(node, type, slideMasterTextStyles) + ';'; // ////////////////Amir///////////////

    var highlight = getTextByPathList(node, ['a:rPr', 'a:highlight']);

    if (highlight !== undefined) {
      styleText += 'background-color:#' + getSolidFill(highlight) + ';';
      styleText += 'Opacity:' + getColorOpacity(highlight) + ';';
    } // /////////////////////////////////////////


    var cssName = '';

    if (styleText in styleTable) {
      cssName = styleTable[styleText]['name'];
    } else {
      cssName = '_css_' + (Object.keys(styleTable).length + 1);
      styleTable[styleText] = {
        'name': cssName,
        'text': styleText
      };
    }

    var linkID = getTextByPathList(node, ['a:rPr', 'a:hlinkClick', 'attrs', 'r:id']); // get link colors : TODO

    if (linkID !== undefined) {
      var linkURL = warpObj['slideResObj'][linkID]['target'];
      return '<span class=\'text-block ' + cssName + '\'><a href=\'' + linkURL + '\' target=\'_blank\'>' + text.replace(/\s/i, '&nbsp;') + '</a></span>';
    } else {
      return '<span class=\'text-block ' + cssName + '\'>' + text.replace(/\s/i, '&nbsp;') + '</span>';
    }
  }

  function genGlobalCSS() {
    var cssText = '';

    for (var key in styleTable) {
      cssText += 'section .' + styleTable[key]['name'] + '{' + styleTable[key]['text'] + '}\n';
    }

    return cssText;
  }

  function genTable(node, warpObj) {
    var order = node['attrs']['order'];
    var tableNode = getTextByPathList(node, ['a:graphic', 'a:graphicData', 'a:tbl']);
    var xfrmNode = getTextByPathList(node, ['p:xfrm']); // ///////////////////////////////////////Amir////////////////////////////////////////////////

    var getTblPr = getTextByPathList(node, ['a:graphic', 'a:graphicData', 'a:tbl', 'a:tblPr']);
    var getColsGrid = getTextByPathList(node, ['a:graphic', 'a:graphicData', 'a:tbl', 'a:tblGrid', 'a:gridCol']);
    var tblDir = '';

    if (getTblPr !== undefined) {
      var isRTL = getTblPr['attrs']['rtl'];
      tblDir = isRTL === 1 ? 'dir=rtl' : 'dir=ltr';
    }

    var firstRowAttr = getTblPr['attrs']['firstRow']; // associated element <a:firstRow> in the table styles
    // const firstColAttr = getTblPr['attrs']['firstCol'] // associated element <a:firstCol> in the table styles
    // const lastRowAttr = getTblPr['attrs']['lastRow'] // associated element <a:lastRow> in the table styles
    // const lastColAttr = getTblPr['attrs']['lastCol'] // associated element <a:lastCol> in the table styles

    var bandRowAttr = getTblPr['attrs']['bandRow']; // associated element <a:band1H>, <a:band2H> in the table styles
    // const bandColAttr = getTblPr['attrs']['bandCol'] // associated element <a:band1V>, <a:band2V> in the table styles
    // console.log(firstColAttr);
    // //////////////////////////////////////////////////////////////////////////////////////////

    var tableHtml = '<table ' + tblDir + ' style=\'border-collapse: collapse;' + getPosition(xfrmNode, undefined, undefined) + getSize(xfrmNode, undefined, undefined) + ' z-index: ' + order + ';\'>';
    var trNodes = tableNode['a:tr'];

    if (trNodes.constructor === Array) {
      for (var i = 0; i < trNodes.length; i++) {
        // ////////////rows Style ////////////Amir
        var rowHeightParam = trNodes[i]['attrs']['h'];
        var rowHeight = 0;
        var rowsStyl = '';

        if (rowHeightParam !== undefined) {
          rowHeight = parseInt(rowHeightParam) * 96 / 914400;
          rowsStyl += 'height:' + rowHeight + 'px;'; // tableHtml += "<tr style='height:"+rowHeight+"px;'>";
        } // get from Theme (tableStyles.xml) TODO
        // get tableStyleId = a:tbl => a:tblPr => a:tableStyleId


        var thisTblStyle = void 0;
        var tbleStyleId = getTblPr['a:tableStyleId'];

        if (tbleStyleId !== undefined) {
          // get Style from tableStyles.xml by {const tbleStyleId}
          // table style object : tableStyles
          var tbleStylList = tableStyles['a:tblStyleLst']['a:tblStyle'];

          for (var k = 0; k < tbleStylList.length; k++) {
            if (tbleStylList[k]['attrs']['styleId'] === tbleStyleId) {
              thisTblStyle = tbleStylList[k];
            }
          }
        } // console.log(thisTblStyle);


        if (i === 0 && firstRowAttr !== undefined) {
          var fillColor = 'fff';
          var colorOpacity = 1;

          if (thisTblStyle['a:firstRow'] !== undefined) {
            var bgFillschemeClr = getTextByPathList(thisTblStyle, ['a:firstRow', 'a:tcStyle', 'a:fill', 'a:solidFill']);

            if (bgFillschemeClr !== undefined) {
              fillColor = getSolidFill(bgFillschemeClr);
              colorOpacity = getColorOpacity(bgFillschemeClr);
            } // console.log(thisTblStyle["a:firstRow"])
            // borders color
            // borders Width


            var borderStyl = getTextByPathList(thisTblStyle, ['a:firstRow', 'a:tcStyle', 'a:tcBdr']);

            if (borderStyl !== undefined) {
              var rowBorders = getTableBorders(borderStyl);
              rowsStyl += rowBorders;
            } // console.log(thisTblStyle["a:firstRow"])
            // Text Style - TODO


            var rowTxtStyl = getTextByPathList(thisTblStyle, ['a:firstRow', 'a:tcTxStyle']);

            
          }

          rowsStyl += ' background-color:#' + fillColor + ';' + ' opacity:' + colorOpacity + ';';
        } else if (i > 0 && bandRowAttr !== undefined) {
          var _fillColor = 'fff';
          var _colorOpacity = 1;

          if (i % 2 === 0) {
            if (thisTblStyle['a:band2H'] !== undefined) {
              // console.log(thisTblStyle["a:band2H"]);
              var _bgFillschemeClr = getTextByPathList(thisTblStyle, ['a:band2H', 'a:tcStyle', 'a:fill', 'a:solidFill']);

              if (_bgFillschemeClr !== undefined) {
                _fillColor = getSolidFill(_bgFillschemeClr);
                _colorOpacity = getColorOpacity(_bgFillschemeClr);
              } // borders color
              // borders Width


              var _borderStyl = getTextByPathList(thisTblStyle, ['a:band2H', 'a:tcStyle', 'a:tcBdr']);

              if (_borderStyl !== undefined) {
                var _rowBorders = getTableBorders(_borderStyl);

                rowsStyl += _rowBorders;
              } // console.log(thisTblStyle["a:band2H"])
              // Text Style - TODO


              var _rowTxtStyl = getTextByPathList(thisTblStyle, ['a:band2H', 'a:tcTxStyle']);

               // console.log(i,thisTblStyle)

            }
            /* else{
                        const bgFillschemeClr = thisTblStyle["a:wholeTbl"]["a:tcStyle"]["a:fill"]["a:solidFill"];
                        if(bgFillschemeClr !==undefined){
                            fillColor = getSolidFill(bgFillschemeClr);
                            colorOpacity = getColorOpacity(bgFillschemeClr);
                        }
                        //borders color
                        //borders Width
                        const borderStyl = thisTblStyle["a:wholeTbl"]["a:tcStyle"]["a:tcBdr"];
                        if(borderStyl !== undefined){
                            const rowBorders = getTableBorders(borderStyl);
                            rowsStyl += rowBorders;
                        }
                        //console.log(thisTblStyle["a:wholeTbl"])
                         //Text Style - TODO
                        const rowTxtStyl = thisTblStyle["a:wholeTbl"]["a:tcTxStyle"];
                        if(rowTxtStyl !== undefined){
                        }
                    } */

          } else {
            if (thisTblStyle['a:band1H'] !== undefined) {
              var _bgFillschemeClr2 = getTextByPathList(thisTblStyle, ['a:band1H', 'a:tcStyle', 'a:fill', 'a:solidFill']);

              if (_bgFillschemeClr2 !== undefined) {
                _fillColor = getSolidFill(_bgFillschemeClr2);
                _colorOpacity = getColorOpacity(_bgFillschemeClr2);
              } // borders color
              // borders Width


              var _borderStyl2 = getTextByPathList(thisTblStyle, ['a:band1H', 'a:tcStyle', 'a:tcBdr']);

              if (_borderStyl2 !== undefined) {
                var _rowBorders2 = getTableBorders(_borderStyl2);

                rowsStyl += _rowBorders2;
              } // console.log(thisTblStyle["a:band1H"])
              // Text Style - TODO


              var _rowTxtStyl2 = getTextByPathList(thisTblStyle, ['a:band1H', 'a:tcTxStyle']);

              
            }
          }

          rowsStyl += ' background-color:#' + _fillColor + ';' + ' opacity:' + _colorOpacity + ';';
        }

        tableHtml += '<tr style=\'' + rowsStyl + '\'>'; // //////////////////////////////////////////////

        var tcNodes = trNodes[i]['a:tc'];

        if (tcNodes.constructor === Array) {
          for (var j = 0; j < tcNodes.length; j++) {
            var text = genTextBody(tcNodes[j]['a:txBody'], undefined, undefined, undefined, warpObj);
            var rowSpan = getTextByPathList(tcNodes[j], ['attrs', 'rowSpan']);
            var colSpan = getTextByPathList(tcNodes[j], ['attrs', 'gridSpan']);
            var vMerge = getTextByPathList(tcNodes[j], ['attrs', 'vMerge']);
            var hMerge = getTextByPathList(tcNodes[j], ['attrs', 'hMerge']); // Cells Style : TODO /////////////Amir
            // console.log(tcNodes[j]);
            // if(j==0 && ())

            var colWidthParam = getColsGrid[j]['attrs']['w'];
            var colStyl = '';

            if (colWidthParam !== undefined) {
              var colWidth = parseInt(colWidthParam) * 96 / 914400;
              colStyl += 'width:' + colWidth + 'px;';
            }

            var getFill = tcNodes[j]['a:tcPr']['a:solidFill'];
            var _fillColor2 = '';
            var _colorOpacity2 = 1;

            if (getFill !== undefined) {
              // console.log(getFill);
              _fillColor2 = getSolidFill(getFill);
              _colorOpacity2 = getColorOpacity(getFill);
            } else {
              // get from Theme (tableStyles.xml) TODO
              // get tableStyleId = a:tbl => a:tblPr => a:tableStyleId
               // console.log(tbleStyleId);

            }

            if (_fillColor2 !== '') {
              colStyl += ' background-color:#' + _fillColor2 + ';';
              colStyl += ' opacity' + _colorOpacity2 + ';';
            } // console.log(fillColor);
            // //////////////////////////////////


            if (rowSpan !== undefined) {
              tableHtml += '<td rowspan=\'' + parseInt(rowSpan) + '\' style=\'' + colStyl + '\'>' + text + '</td>';
            } else if (colSpan !== undefined) {
              tableHtml += '<td colspan=\'' + parseInt(colSpan) + '\' style=\'' + colStyl + '\'>' + text + '</td>';
            } else if (vMerge === undefined && hMerge === undefined) {
              tableHtml += '<td style=\'' + colStyl + '\'>' + text + '</td>';
            }
          }
        } else {
          var _text = genTextBody(tcNodes['a:txBody']); // Cells Style : TODO /////////////Amir


          var _colWidthParam = getColsGrid[0]['attrs']['w'];
          var _colStyl = '';

          if (_colWidthParam !== undefined) {
            var _colWidth = parseInt(_colWidthParam) * 96 / 914400;

            _colStyl += 'width:' + _colWidth + 'px;';
          }

          var _getFill = tcNodes['a:tcPr']['a:solidFill'];
          var _fillColor3 = '';
          var _colorOpacity3 = 1;

          if (_getFill !== undefined) {
            // console.log(getFill);
            _fillColor3 = getSolidFill(_getFill);
            _colorOpacity3 = getColorOpacity(_getFill);
          } else {// get from Theme TODO
          }

          if (_fillColor3 !== '') {
            _colStyl += ' background-color:#' + _fillColor3 + ';';
            _colStyl += ' opacity' + _colorOpacity3 + ';';
          } // //////////////////////////////////


          tableHtml += '<td style=\'' + _colStyl + '\'>' + _text + '</td>';
        }

        tableHtml += '</tr>';
      }
    } else {
      // ////////////row height ////////////Amir
      var _rowHeightParam = trNodes['attrs']['h'];
      var _rowHeight = 0;

      if (_rowHeightParam !== undefined) {
        _rowHeight = parseInt(_rowHeightParam) * 96 / 914400;
        tableHtml += '<tr style=\'height:' + _rowHeight + 'px;\'>';
      } else {
        tableHtml += '<tr>';
      } // //////////////////////////////////////////////


      var _tcNodes = trNodes['a:tc'];

      if (_tcNodes.constructor === Array) {
        for (var _j2 = 0; _j2 < _tcNodes.length; _j2++) {
          var _text2 = genTextBody(_tcNodes[_j2]['a:txBody']); // Cells Style : TODO /////////////Amir


          var _colWidthParam2 = getColsGrid[_j2]['attrs']['w'];
          var _colStyl2 = '';

          if (_colWidthParam2 !== undefined) {
            var _colWidth2 = parseInt(_colWidthParam2) * 96 / 914400;

            _colStyl2 += 'width:' + _colWidth2 + 'px;';
          }

          var _getFill2 = _tcNodes[_j2]['a:tcPr']['a:solidFill'];
          var _fillColor4 = '';
          var _colorOpacity4 = 1;

          if (_getFill2 !== undefined) {
            _fillColor4 = getSolidFill(_getFill2);
            _colorOpacity4 = getColorOpacity(_getFill2);
          } else {// get from Theme TODO
            // get tableStyleId
            // a:tbl => a:tblPr => a:tableStyleId
          }

          if (_fillColor4 !== '') {
            _colStyl2 += ' background-color:#' + _fillColor4 + ';';
            _colStyl2 += ' opacity' + _colorOpacity4 + ';';
          } // //////////////////////////////////


          tableHtml += '<td style=\'' + _colStyl2 + '\'>' + _text2 + '</td>';
        }
      } else {
        var _text3 = genTextBody(_tcNodes['a:txBody']); // Cells Style : TODO /////////////Amir


        var _colWidthParam3 = getColsGrid[0]['attrs']['w'];
        var _colStyl3 = '';

        if (_colWidthParam3 !== undefined) {
          var _colWidth3 = parseInt(_colWidthParam3) * 96 / 914400;

          _colStyl3 += 'width:' + _colWidth3 + 'px;';
        }

        var _getFill3 = _tcNodes['a:tcPr']['a:solidFill'];
        var _fillColor5 = '';
        var _colorOpacity5 = 1;

        if (_getFill3 !== undefined) {
          // console.log(getFill);
          _fillColor5 = getSolidFill(_getFill3);
          _colorOpacity5 = getColorOpacity(_getFill3);
        } else {// get from Theme TODO
        }

        if (_fillColor5 !== '') {
          _colStyl3 += ' background-color:#' + _fillColor5 + ';';
          _colStyl3 += ' opacity' + _colorOpacity5 + ';';
        } // //////////////////////////////////


        tableHtml += '<td style=\'' + _colStyl3 + '\'>' + _text3 + '</td>';
      }

      tableHtml += '</tr>';
    }

    return tableHtml;
  }

  function genDiagram(node, warpObj) {
    // const order = node['attrs']['order']
    var xfrmNode = getTextByPathList(node, ['p:xfrm']);
    return '<div class=\'block content\' style=\'border: 1px dotted;' + getPosition(xfrmNode, undefined, undefined) + getSize(xfrmNode, undefined, undefined) + '\'>TODO: diagram</div>';
  }

  function getPosition(slideSpNode, slideLayoutSpNode, slideMasterSpNode) {
    var off;
    var x = -1;
    var y = -1;

    if (slideSpNode !== undefined) {
      off = slideSpNode['a:off']['attrs'];
    } else if (slideLayoutSpNode !== undefined) {
      off = slideLayoutSpNode['a:off']['attrs'];
    } else if (slideMasterSpNode !== undefined) {
      off = slideMasterSpNode['a:off']['attrs'];
    }

    if (off === undefined) {
      return '';
    } else {
      x = parseInt(off['x']) * 96 / 914400;
      y = parseInt(off['y']) * 96 / 914400;
      return isNaN(x) || isNaN(y) ? '' : 'top:' + y + 'px; left:' + x + 'px;';
    }
  }

  function getSize(slideSpNode, slideLayoutSpNode, slideMasterSpNode) {
    var ext;
    var w = -1;
    var h = -1;

    if (slideSpNode !== undefined) {
      ext = slideSpNode['a:ext']['attrs'];
    } else if (slideLayoutSpNode !== undefined) {
      ext = slideLayoutSpNode['a:ext']['attrs'];
    } else if (slideMasterSpNode !== undefined) {
      ext = slideMasterSpNode['a:ext']['attrs'];
    }

    if (ext === undefined) {
      return '';
    } else {
      w = parseInt(ext['cx']) * 96 / 914400;
      h = parseInt(ext['cy']) * 96 / 914400;
      return isNaN(w) || isNaN(h) ? '' : 'width:' + w + 'px; height:' + h + 'px;';
    }
  }

  function getHorizontalAlign(node, slideLayoutSpNode, slideMasterSpNode, type, slideMasterTextStyles) {
    var algn = getTextByPathList(node, ['a:pPr', 'attrs', 'algn']);

    if (algn === undefined) {
      algn = getTextByPathList(slideLayoutSpNode, ['p:txBody', 'a:p', 'a:pPr', 'attrs', 'algn']);

      if (algn === undefined) {
        algn = getTextByPathList(slideMasterSpNode, ['p:txBody', 'a:p', 'a:pPr', 'attrs', 'algn']);

        if (algn === undefined) {
          switch (type) {
            case 'title':
            case 'subTitle':
            case 'ctrTitle':
              {
                algn = getTextByPathList(slideMasterTextStyles, ['p:titleStyle', 'a:lvl1pPr', 'attrs', 'alng']);
                break;
              }

            default:
              {
                algn = getTextByPathList(slideMasterTextStyles, ['p:otherStyle', 'a:lvl1pPr', 'attrs', 'alng']);
              }
          }
        }
      }
    } // TODO:


    if (algn === undefined) {
      if (type === 'title' || type === 'subTitle' || type === 'ctrTitle') {
        return 'h-mid';
      } else if (type === 'sldNum') {
        return 'h-right';
      }
    }

    return algn === 'ctr' ? 'h-mid' : algn === 'r' ? 'h-right' : 'h-left';
  }

  function getVerticalAlign(node, slideLayoutSpNode, slideMasterSpNode, type, slideMasterTextStyles) {
    // 上中下對齊: X, <a:bodyPr anchor="ctr">, <a:bodyPr anchor="b">
    var anchor = getTextByPathList(node, ['p:txBody', 'a:bodyPr', 'attrs', 'anchor']);

    if (anchor === undefined) {
      anchor = getTextByPathList(slideLayoutSpNode, ['p:txBody', 'a:bodyPr', 'attrs', 'anchor']);

      if (anchor === undefined) {
        anchor = getTextByPathList(slideMasterSpNode, ['p:txBody', 'a:bodyPr', 'attrs', 'anchor']);
      }
    }

    return anchor === 'ctr' ? 'v-mid' : anchor === 'b' ? 'v-down' : 'v-up';
  }

  function getFontType(node, type, slideMasterTextStyles) {
    var typeface = getTextByPathList(node, ['a:rPr', 'a:latin', 'attrs', 'typeface']);

    if (typeface === undefined) {
      var fontSchemeNode = getTextByPathList(themeContent, ['a:theme', 'a:themeElements', 'a:fontScheme']);

      if (type === 'title' || type === 'subTitle' || type === 'ctrTitle') {
        typeface = getTextByPathList(fontSchemeNode, ['a:majorFont', 'a:latin', 'attrs', 'typeface']);
      } else if (type === 'body') {
        typeface = getTextByPathList(fontSchemeNode, ['a:minorFont', 'a:latin', 'attrs', 'typeface']);
      } else {
        typeface = getTextByPathList(fontSchemeNode, ['a:minorFont', 'a:latin', 'attrs', 'typeface']);
      }
    }

    return typeface === undefined ? 'inherit' : typeface;
  }

  function getFontColor(node, type, slideMasterTextStyles) {
    var solidFillNode = getTextByPathStr(node, 'a:rPr a:solidFill');
    var color = getSolidFill(solidFillNode); // console.log(themeContent)
    // const schemeClr = getTextByPathList(buClrNode ,["a:schemeClr", "attrs","val"]);

    return color === undefined || color === 'FFF' ? '#000' : '#' + color;
  }

  function getFontSize(node, slideLayoutSpNode, slideMasterSpNode, type, slideMasterTextStyles) {
    var fontSize;
    var sz;

    if (node['a:rPr'] !== undefined) {
      fontSize = parseInt(node['a:rPr']['attrs']['sz']) / 100;
    }

    if (isNaN(fontSize) || fontSize === undefined) {
      sz = getTextByPathList(slideLayoutSpNode, ['p:txBody', 'a:lstStyle', 'a:lvl1pPr', 'a:defRPr', 'attrs', 'sz']);
      fontSize = parseInt(sz) / 100;
    }

    if (isNaN(fontSize) || fontSize === undefined) {
      if (type === 'title' || type === 'subTitle' || type === 'ctrTitle') {
        sz = getTextByPathList(slideMasterTextStyles, ['p:titleStyle', 'a:lvl1pPr', 'a:defRPr', 'attrs', 'sz']);
      } else if (type === 'body') {
        sz = getTextByPathList(slideMasterTextStyles, ['p:bodyStyle', 'a:lvl1pPr', 'a:defRPr', 'attrs', 'sz']);
      } else if (type === 'dt' || type === 'sldNum') {
        sz = '1200';
      } else if (type === undefined) {
        sz = getTextByPathList(slideMasterTextStyles, ['p:otherStyle', 'a:lvl1pPr', 'a:defRPr', 'attrs', 'sz']);
      }

      fontSize = parseInt(sz) / 100;
    }

    var baseline = getTextByPathList(node, ['a:rPr', 'attrs', 'baseline']);

    if (baseline !== undefined && !isNaN(fontSize)) {
      fontSize -= 10;
    }

    return isNaN(fontSize) ? 'inherit' : fontSize + 'pt';
  }

  function getFontBold(node, type, slideMasterTextStyles) {
    return node['a:rPr'] !== undefined && node['a:rPr']['attrs']['b'] === '1' ? 'bold' : 'initial';
  }

  function getFontItalic(node, type, slideMasterTextStyles) {
    return node['a:rPr'] !== undefined && node['a:rPr']['attrs']['i'] === '1' ? 'italic' : 'normal';
  }

  function getFontDecoration(node, type, slideMasterTextStyles) {
    // /////////////////////////////Amir///////////////////////////////
    if (node['a:rPr'] !== undefined) {
      var underLine = node['a:rPr']['attrs']['u'] !== undefined ? node['a:rPr']['attrs']['u'] : 'none';
      var strikethrough = node['a:rPr']['attrs']['strike'] !== undefined ? node['a:rPr']['attrs']['strike'] : 'noStrike'; // console.log("strikethrough: "+strikethrough);

      if (underLine !== 'none' && strikethrough === 'noStrike') {
        return 'underline';
      } else if (underLine === 'none' && strikethrough !== 'noStrike') {
        return 'line-through';
      } else if (underLine !== 'none' && strikethrough !== 'noStrike') {
        return 'underline line-through';
      } else {
        return 'initial';
      }
    } else {
      return 'initial';
    } // ///////////////////////////////////////////////////////////////
    // return (node["a:rPr"] !== undefined && node["a:rPr"]["attrs"]["u"] === "sng") ? "underline" : "initial";

  } // //////////////////////////////////Amir/////////////////////////////////////


  function getTextHorizontalAlign(node, type, slideMasterTextStyles) {
    var getAlgn = getTextByPathList(node, ['a:pPr', 'attrs', 'algn']);
    var align = 'initial';

    if (getAlgn !== undefined) {
      switch (getAlgn) {
        case 'l':
          {
            align = 'left';
            break;
          }

        case 'r':
          {
            align = 'right';
            break;
          }

        case 'ctr':
          {
            align = 'center';
            break;
          }

        case 'just':
          {
            align = 'justify';
            break;
          }

        case 'dist':
          {
            align = 'justify';
            break;
          }

        default:
          align = 'initial';
      }
    }

    return align;
  } // ///////////////////////////////////////////////////////////////////


  function getTextVerticalAlign(node, type, slideMasterTextStyles) {
    var baseline = getTextByPathList(node, ['a:rPr', 'attrs', 'baseline']);
    return baseline === undefined ? 'baseline' : parseInt(baseline) / 1000 + '%';
  } // /////////////////////////////////Amir/////////////////////////////

  /*
  function getTextDirection (node, type, slideMasterTextStyles) {
  // get lvl
  const pprLvl = getTextByPathList(node, ['a:pPr', 'attrs', 'lvl'])
  const pprLvlNum = pprLvl === undefined ? 1 : Number(pprLvl) + 1
  const lvlNode = 'a:lvl' + pprLvlNum + 'pPr'
  const pprAlgn = getTextByPathList(node, ['a:pPr', 'attrs', 'algn'])
  const isDir = getTextByPathList(slideMasterTextStyles, ['p:bodyStyle', lvlNode, 'attrs', 'rtl'])
  // const tmp = getTextByPathList(node, ["a:r", "a:t"]);
  let dir = ''
  if (isDir !== undefined) {
    if (isDir === '1' && (pprAlgn === undefined || pprAlgn === 'r')) {
      dir = 'rtl'
    } else { // isDir =="0"
      dir = 'ltr'
    }
  }
  // console.log(tmp,isDir,pprAlgn,dir)
  return dir
  }
  */


  function getTableBorders(node) {
    var borderStyle = '';
    var obj;
    var borders;

    if (node['a:bottom'] !== undefined) {
      obj = {
        'p:spPr': {
          'a:ln': node['a:bottom']['a:ln']
        }
      };
      borders = getBorder(obj, false);
      borderStyle += borders.replace('border', 'border-bottom');
    }

    if (node['a:top'] !== undefined) {
      obj = {
        'p:spPr': {
          'a:ln': node['a:top']['a:ln']
        }
      };
      borders = getBorder(obj, false);
      borderStyle += borders.replace('border', 'border-top');
    }

    if (node['a:right'] !== undefined) {
      obj = {
        'p:spPr': {
          'a:ln': node['a:right']['a:ln']
        }
      };
      borders = getBorder(obj, false);
      borderStyle += borders.replace('border', 'border-right');
    }

    if (node['a:left'] !== undefined) {
      obj = {
        'p:spPr': {
          'a:ln': node['a:left']['a:ln']
        }
      };
      borders = getBorder(obj, false);
      borderStyle += borders.replace('border', 'border-left');
    }

    return borderStyle;
  } // ////////////////////////////////////////////////////////////////


  function getBorder(node, isSvgMode) {
    var cssText = 'border: '; // 1. presentationML

    var lineNode = node['p:spPr']['a:ln']; // Border width: 1pt = 12700, default = 0.75pt

    var borderWidth = parseInt(getTextByPathList(lineNode, ['attrs', 'w'])) / 12700;

    if (isNaN(borderWidth) || borderWidth < 1) {
      cssText += '1pt ';
    } else {
      cssText += borderWidth + 'pt ';
    } // Border type


    var borderType = getTextByPathList(lineNode, ['a:prstDash', 'attrs', 'val']);
    var strokeDasharray = '0';

    switch (borderType) {
      case 'solid':
        {
          cssText += 'solid';
          strokeDasharray = '0';
          break;
        }

      case 'dash':
        {
          cssText += 'dashed';
          strokeDasharray = '5';
          break;
        }

      case 'dashDot':
        {
          cssText += 'dashed';
          strokeDasharray = '5, 5, 1, 5';
          break;
        }

      case 'dot':
        {
          cssText += 'dotted';
          strokeDasharray = '1, 5';
          break;
        }

      case 'lgDash':
        {
          cssText += 'dashed';
          strokeDasharray = '10, 5';
          break;
        }

      case 'lgDashDotDot':
        {
          cssText += 'dashed';
          strokeDasharray = '10, 5, 1, 5, 1, 5';
          break;
        }

      case 'sysDash':
        {
          cssText += 'dashed';
          strokeDasharray = '5, 2';
          break;
        }

      case 'sysDashDot':
        {
          cssText += 'dashed';
          strokeDasharray = '5, 2, 1, 5';
          break;
        }

      case 'sysDashDotDot':
        {
          cssText += 'dashed';
          strokeDasharray = '5, 2, 1, 5, 1, 5';
          break;
        }

      case 'sysDot':
        {
          cssText += 'dotted';
          strokeDasharray = '2, 5';
          break;
        }

      default:
        {
          cssText += 'solid';
          strokeDasharray = '0';
        }
    } // Border color


    var borderColor = getTextByPathList(lineNode, ['a:solidFill', 'a:srgbClr', 'attrs', 'val']);

    if (borderColor === undefined) {
      var schemeClrNode = getTextByPathList(lineNode, ['a:solidFill', 'a:schemeClr']);

      if (schemeClrNode !== undefined) {
        var schemeClr = 'a:' + getTextByPathList(schemeClrNode, ['attrs', 'val']);
        borderColor = getSchemeColorFromTheme(schemeClr, undefined);
      }
    } // 2. drawingML namespace


    if (borderColor === undefined) {
      var _schemeClrNode = getTextByPathList(node, ['p:style', 'a:lnRef', 'a:schemeClr']);

      if (_schemeClrNode !== undefined) {
        var _schemeClr = 'a:' + getTextByPathList(_schemeClrNode, ['attrs', 'val']);

        borderColor = getSchemeColorFromTheme(_schemeClr, undefined);
      }

      if (borderColor !== undefined) {
        var shade = getTextByPathList(_schemeClrNode, ['a:shade', 'attrs', 'val']);

        if (shade !== undefined) {
          shade = parseInt(shade) / 100000;
          var color = new Color('#' + borderColor);
          color.setLum(color.hsl.l * shade);
          borderColor = color.hex.replace('#', '');
        }
      }
    }

    if (borderColor === undefined) {
      if (isSvgMode) {
        borderColor = 'none';
      } else {
        borderColor = '#000';
      }
    } else {
      borderColor = '#' + borderColor;
    }

    cssText += ' ' + borderColor + ' ';

    if (isSvgMode) {
      return {
        'color': borderColor,
        'width': borderWidth,
        'type': borderType,
        'strokeDasharray': strokeDasharray
      };
    } else {
      return cssText + ';';
    }
  }

  function getSlideBackgroundFill(slideContent, slideLayoutContent, slideMasterContent, warpObj) {
    // console.log(slideContent)
    // getFillType(node)
    var bgPr = getTextByPathList(slideContent, ['p:sld', 'p:cSld', 'p:bg', 'p:bgPr']);
    var bgRef = getTextByPathList(slideContent, ['p:sld', 'p:cSld', 'p:bg', 'p:bgRef']);
    var bgcolor;

    if (bgPr !== undefined) {
      // bgcolor = "background-color: blue;";
      var bgFillTyp = getFillType(bgPr);

      if (bgFillTyp === 'SOLID_FILL') {
        var sldFill = bgPr['a:solidFill'];
        var bgColor = getSolidFill(sldFill);
        var sldTint = getColorOpacity(sldFill);
        bgcolor = 'background: rgba(' + hexToRgbNew(bgColor) + ',' + sldTint + ');';
      } else if (bgFillTyp === 'GRADIENT_FILL') {
        var grdFill = bgPr['a:gradFill']; // const grdFillVals =  getGradientFill(grdFill);
        // console.log("grdFillVals",grdFillVals)

        var gsLst = grdFill['a:gsLst']['a:gs']; // get start color
        // let startColorNode
        // let endColorNode

        var colorArray = [];
        var tintArray = [];

        for (var i = 0; i < gsLst.length; i++) {
          var loTint = void 0;
          var loColor = void 0;

          if (gsLst[i]['a:srgbClr'] !== undefined) {
            loColor = getTextByPathList(gsLst[i], ['a:srgbClr', 'attrs', 'val']); // #...

            loTint = getTextByPathList(gsLst[i], ['a:srgbClr', 'a:tint', 'attrs', 'val']);
          } else if (gsLst[i]['a:schemeClr'] !== undefined) {
            // a:schemeClr
            var schemeClr = getTextByPathList(gsLst[i], ['a:schemeClr', 'attrs', 'val']);
            loColor = getSchemeColorFromTheme('a:' + schemeClr, slideMasterContent); // #...

            loTint = getTextByPathList(gsLst[i], ['a:schemeClr', 'a:tint', 'attrs', 'val']); // console.log("schemeClr",schemeClr,slideMasterContent)
          } // console.log("loColor",loColor)


          colorArray[i] = loColor;
          tintArray[i] = loTint !== undefined ? parseInt(loTint) / 100000 : 1;
        } // get rot


        var lin = grdFill['a:lin'];
        var rot = 90;

        if (lin !== undefined) {
          rot = angleToDegrees(lin['attrs']['ang']) + 90;
        }

        bgcolor = 'background: linear-gradient(' + rot + 'deg,';

        for (var _i10 = 0; _i10 < gsLst.length; _i10++) {
          if (_i10 === gsLst.length - 1) {
            bgcolor += 'rgba(' + hexToRgbNew(colorArray[_i10]) + ',' + tintArray[_i10] + ')' + ');';
          } else {
            bgcolor += 'rgba(' + hexToRgbNew(colorArray[_i10]) + ',' + tintArray[_i10] + ')' + ', ';
          }
        }
      } else if (bgFillTyp === 'PIC_FILL') {
        var picFillBase64 = getPicFill('slideBg', bgPr['a:blipFill'], warpObj);
        var ordr = bgPr['attrs']['order']; // a:srcRect
        // a:stretch => a:fillRect =>attrs (l:-17000, r:-17000)

        bgcolor = 'background-image: url(' + picFillBase64 + ');  z-index: ' + ordr + ';'; // console.log(picFillBase64);
      } // console.log(slideContent,slideMasterContent,colorArray,tintArray,rot,bgcolor)

    } else if (bgRef !== undefined) {
      // console.log("slideContent",bgRef)
      var phClr;

      if (bgRef['a:srgbClr'] !== undefined) {
        phClr = getTextByPathList(bgRef, ['a:srgbClr', 'attrs', 'val']); // #...
      } else if (bgRef['a:schemeClr'] !== undefined) {
        // a:schemeClr
        var _schemeClr2 = getTextByPathList(bgRef, ['a:schemeClr', 'attrs', 'val']);

        phClr = getSchemeColorFromTheme('a:' + _schemeClr2, slideMasterContent); // #...
        // console.log("schemeClr",schemeClr,"phClr=",phClr)
      }

      var idx = Number(bgRef['attrs']['idx']);

      if (idx === 0 || idx === 1000) {// no background
      } else if (idx > 0 && idx < 1000) {// fillStyleLst in themeContent
        // themeContent["a:fmtScheme"]["a:fillStyleLst"]
        // bgcolor = "background: red;";
      } else if (idx > 1000) {
        // bgFillStyleLst  in themeContent
        // themeContent["a:fmtScheme"]["a:bgFillStyleLst"]
        var trueIdx = idx - 1000;
        var bgFillLst = themeContent['a:theme']['a:themeElements']['a:fmtScheme']['a:bgFillStyleLst'];
        var sortblAry = [];
        Object.keys(bgFillLst).forEach(function (key) {
          var bgFillLstTyp = bgFillLst[key];

          if (key !== 'attrs') {
            if (bgFillLstTyp.constructor === Array) {
              for (var _i11 = 0; _i11 < bgFillLstTyp.length; _i11++) {
                var obj = {};
                obj[key] = bgFillLstTyp[_i11];
                obj['idex'] = bgFillLstTyp[_i11]['attrs']['order'];
                sortblAry.push(obj);
              }
            } else {
              var _obj = {};
              _obj[key] = bgFillLstTyp;
              _obj['idex'] = bgFillLstTyp['attrs']['order'];
              sortblAry.push(_obj);
            }
          }
        });
        var sortByOrder = sortblAry.slice(0);
        sortByOrder.sort(function (a, b) {
          return a.idex - b.idex;
        });
        var bgFillLstIdx = sortByOrder[trueIdx - 1];

        var _bgFillTyp = getFillType(bgFillLstIdx);

        if (_bgFillTyp === 'SOLID_FILL') {
          var _sldFill = bgFillLstIdx['a:solidFill']; // const sldBgColor = getSolidFill(sldFill);

          var _sldTint = getColorOpacity(_sldFill);

          bgcolor = 'background: rgba(' + hexToRgbNew(phClr) + ',' + _sldTint + ');'; // console.log("slideMasterContent - sldFill",sldFill)
        } else if (_bgFillTyp === 'GRADIENT_FILL') {
          var _grdFill = bgFillLstIdx['a:gradFill'];
          var _gsLst = _grdFill['a:gsLst']['a:gs']; // get start color
          // let startColorNode
          // let endColorNode

          var _tintArray = [];

          for (var _i12 = 0; _i12 < _gsLst.length; _i12++) {
            var _loTint = getTextByPathList(_gsLst[_i12], ['a:schemeClr', 'a:tint', 'attrs', 'val']);

            _tintArray[_i12] = _loTint !== undefined ? parseInt(_loTint) / 100000 : 1;
          } // console.log("gsLst",gsLst)
          // get rot


          var _lin = _grdFill['a:lin'];
          var _rot = 90;

          if (_lin !== undefined) {
            _rot = angleToDegrees(_lin['attrs']['ang']) + 90;
          }

          bgcolor = 'background: linear-gradient(' + _rot + 'deg,';

          for (var _i13 = 0; _i13 < _gsLst.length; _i13++) {
            if (_i13 === _gsLst.length - 1) {
              bgcolor += 'rgba(' + hexToRgbNew(phClr) + ',' + _tintArray[_i13] + ')' + ');';
            } else {
              bgcolor += 'rgba(' + hexToRgbNew(phClr) + ',' + _tintArray[_i13] + ')' + ', ';
            }
          }
        }
      }
    } else {
      bgPr = getTextByPathList(slideLayoutContent, ['p:sldLayout', 'p:cSld', 'p:bg', 'p:bgPr']);
      bgRef = getTextByPathList(slideLayoutContent, ['p:sldLayout', 'p:cSld', 'p:bg', 'p:bgRef']); // console.log("slideLayoutContent",bgPr,bgRef)

      if (bgPr !== undefined) {
        var _bgFillTyp2 = getFillType(bgPr);

        if (_bgFillTyp2 === 'SOLID_FILL') {
          var _sldFill2 = bgPr['a:solidFill'];

          var _bgColor = getSolidFill(_sldFill2);

          var _sldTint2 = getColorOpacity(_sldFill2);

          bgcolor = 'background: rgba(' + hexToRgbNew(_bgColor) + ',' + _sldTint2 + ');';
        } else if (_bgFillTyp2 === 'GRADIENT_FILL') {
          var _grdFill2 = bgPr['a:gradFill']; // const grdFillVals =  getGradientFill(grdFill);
          // console.log("grdFillVals",grdFillVals)

          var _gsLst2 = _grdFill2['a:gsLst']['a:gs']; // get start color
          // let startColorNode
          // let endColorNode

          var _colorArray = [];
          var _tintArray2 = [];

          for (var _i14 = 0; _i14 < _gsLst2.length; _i14++) {
            var _loTint2 = void 0;

            var _loColor = void 0;

            if (_gsLst2[_i14]['a:srgbClr'] !== undefined) {
              _loColor = getTextByPathList(_gsLst2[_i14], ['a:srgbClr', 'attrs', 'val']); // #...

              _loTint2 = getTextByPathList(_gsLst2[_i14], ['a:srgbClr', 'a:tint', 'attrs', 'val']);
            } else if (_gsLst2[_i14]['a:schemeClr'] !== undefined) {
              // a:schemeClr
              var _schemeClr3 = getTextByPathList(_gsLst2[_i14], ['a:schemeClr', 'attrs', 'val']);

              _loColor = getSchemeColorFromTheme('a:' + _schemeClr3, slideMasterContent); // #...

              _loTint2 = getTextByPathList(_gsLst2[_i14], ['a:schemeClr', 'a:tint', 'attrs', 'val']); // console.log("schemeClr",schemeClr,slideMasterContent)
            } // console.log("loColor",loColor)


            _colorArray[_i14] = _loColor;
            _tintArray2[_i14] = _loTint2 !== undefined ? parseInt(_loTint2) / 100000 : 1;
          } // console.log("colorArray",colorArray,"tintArray",tintArray)
          // get rot


          var _lin2 = _grdFill2['a:lin'];
          var _rot2 = 90;

          if (_lin2 !== undefined) {
            _rot2 = angleToDegrees(_lin2['attrs']['ang']) + 90;
          }

          bgcolor = 'background: linear-gradient(' + _rot2 + 'deg,';

          for (var _i15 = 0; _i15 < _gsLst2.length; _i15++) {
            if (_i15 === _gsLst2.length - 1) {
              bgcolor += 'rgba(' + hexToRgbNew(_colorArray[_i15]) + ',' + _tintArray2[_i15] + ')' + ');';
            } else {
              bgcolor += 'rgba(' + hexToRgbNew(_colorArray[_i15]) + ',' + _tintArray2[_i15] + ')' + ', ';
            }
          }
        } else if (_bgFillTyp2 === 'PIC_FILL') {
          // console.log("bgPr",bgPr,"bgFillTyp",bgFillTyp)
          var _picFillBase = getPicFill('layoutBg', bgPr['a:blipFill'], warpObj);

          var _ordr = bgPr['attrs']['order']; // a:srcRect
          // a:stretch => a:fillRect =>attrs (l:-17000, r:-17000)

          bgcolor = 'background-image: url(' + _picFillBase + ');  z-index: ' + _ordr + ';'; // console.log(warpObj)
        } // console.log("slideLayoutContent",bgcolor)

      } else if (bgRef !== undefined) {
        bgcolor = 'background: red;';
      } else {
        bgPr = getTextByPathList(slideMasterContent, ['p:sldMaster', 'p:cSld', 'p:bg', 'p:bgPr']);
        bgRef = getTextByPathList(slideMasterContent, ['p:sldMaster', 'p:cSld', 'p:bg', 'p:bgRef']); // console.log("bgRef",bgRef["a:schemeClr"]["attrs"]["val"])

        if (bgPr !== undefined) {
          var _bgFillTyp3 = getFillType(bgPr);

          if (_bgFillTyp3 === 'SOLID_FILL') {
            var _sldFill3 = bgPr['a:solidFill'];

            var _bgColor2 = getSolidFill(_sldFill3);

            var _sldTint3 = getColorOpacity(_sldFill3);

            bgcolor = 'background: rgba(' + hexToRgbNew(_bgColor2) + ',' + _sldTint3 + ');';
          } else if (_bgFillTyp3 === 'GRADIENT_FILL') {
            var _grdFill3 = bgPr['a:gradFill']; // const grdFillVals =  getGradientFill(grdFill);
            // console.log("grdFillVals",grdFillVals)

            var _gsLst3 = _grdFill3['a:gsLst']['a:gs']; // get start color
            // let startColorNode
            // let endColorNode

            var _colorArray2 = [];
            var _tintArray3 = [];

            for (var _i16 = 0; _i16 < _gsLst3.length; _i16++) {
              var _loTint3 = void 0;

              var _loColor2 = void 0;

              if (_gsLst3[_i16]['a:srgbClr'] !== undefined) {
                _loColor2 = getTextByPathList(_gsLst3[_i16], ['a:srgbClr', 'attrs', 'val']); // #...

                _loTint3 = getTextByPathList(_gsLst3[_i16], ['a:srgbClr', 'a:tint', 'attrs', 'val']);
              } else if (_gsLst3[_i16]['a:schemeClr'] !== undefined) {
                // a:schemeClr
                var _schemeClr4 = getTextByPathList(_gsLst3[_i16], ['a:schemeClr', 'attrs', 'val']);

                _loColor2 = getSchemeColorFromTheme('a:' + _schemeClr4, slideMasterContent); // #...

                _loTint3 = getTextByPathList(_gsLst3[_i16], ['a:schemeClr', 'a:tint', 'attrs', 'val']); // console.log("schemeClr",schemeClr,slideMasterContent)
              } // console.log("loColor",loColor)


              _colorArray2[_i16] = _loColor2;
              _tintArray3[_i16] = _loTint3 !== undefined ? parseInt(_loTint3) / 100000 : 1;
            } // console.log("colorArray",colorArray,"tintArray",tintArray)
            // get rot


            var _lin3 = _grdFill3['a:lin'];
            var _rot3 = 90;

            if (_lin3 !== undefined) {
              _rot3 = angleToDegrees(_lin3['attrs']['ang']) + 90;
            }

            bgcolor = 'background: linear-gradient(' + _rot3 + 'deg,';

            for (var _i17 = 0; _i17 < _gsLst3.length; _i17++) {
              if (_i17 === _gsLst3.length - 1) {
                bgcolor += 'rgba(' + hexToRgbNew(_colorArray2[_i17]) + ',' + _tintArray3[_i17] + ')' + ');';
              } else {
                bgcolor += 'rgba(' + hexToRgbNew(_colorArray2[_i17]) + ',' + _tintArray3[_i17] + ')' + ', ';
              }
            }
          } else if (_bgFillTyp3 === 'PIC_FILL') {
            // console.log("bgPr",bgPr,"bgFillTyp",bgFillTyp)
            var _picFillBase2 = getPicFill('masterBg', bgPr['a:blipFill'], warpObj);

            var _ordr2 = bgPr['attrs']['order']; // a:srcRect
            // a:stretch => a:fillRect =>attrs (l:-17000, r:-17000)

            bgcolor = 'background-image: url(' + _picFillBase2 + ');  z-index: ' + _ordr2 + ';'; // console.log(warpObj);
          }
        } else if (bgRef !== undefined) {
          // const obj={
          //    "a:solidFill": bgRef
          // }
          // const phClr = getSolidFill(bgRef);
          var _phClr;

          if (bgRef['a:srgbClr'] !== undefined) {
            _phClr = getTextByPathList(bgRef, ['a:srgbClr', 'attrs', 'val']); // #...
          } else if (bgRef['a:schemeClr'] !== undefined) {
            // a:schemeClr
            var _schemeClr5 = getTextByPathList(bgRef, ['a:schemeClr', 'attrs', 'val']);

            _phClr = getSchemeColorFromTheme('a:' + _schemeClr5, slideMasterContent); // #...
            // console.log("phClr",phClr)
          }

          var _idx2 = Number(bgRef['attrs']['idx']); // console.log("phClr=",phClr,"idx=",idx)


          if (_idx2 === 0 || _idx2 === 1000) {// no background
          } else if (_idx2 > 0 && _idx2 < 1000) {// fillStyleLst in themeContent
            // themeContent["a:fmtScheme"]["a:fillStyleLst"]
            // bgcolor = "background: red;";
          } else if (_idx2 > 1000) {
            // bgFillStyleLst  in themeContent
            // themeContent["a:fmtScheme"]["a:bgFillStyleLst"]
            var _trueIdx = _idx2 - 1000;

            var _bgFillLst = themeContent['a:theme']['a:themeElements']['a:fmtScheme']['a:bgFillStyleLst'];
            var _sortblAry = [];
            Object.keys(_bgFillLst).forEach(function (key) {
              // console.log("cubicBezTo["+key+"]:");
              var bgFillLstTyp = _bgFillLst[key];

              if (key !== 'attrs') {
                if (bgFillLstTyp.constructor === Array) {
                  for (var _i18 = 0; _i18 < bgFillLstTyp.length; _i18++) {
                    var obj = {};
                    obj[key] = bgFillLstTyp[_i18];
                    obj['idex'] = bgFillLstTyp[_i18]['attrs']['order'];

                    _sortblAry.push(obj);
                  }
                } else {
                  var _obj2 = {};
                  _obj2[key] = bgFillLstTyp;
                  _obj2['idex'] = bgFillLstTyp['attrs']['order'];

                  _sortblAry.push(_obj2);
                }
              }
            });

            var _sortByOrder = _sortblAry.slice(0);

            _sortByOrder.sort(function (a, b) {
              return a.idex - b.idex;
            });

            var _bgFillLstIdx = _sortByOrder[_trueIdx - 1];

            var _bgFillTyp4 = getFillType(_bgFillLstIdx); // console.log("bgFillLstIdx",bgFillLstIdx);


            if (_bgFillTyp4 === 'SOLID_FILL') {
              var _sldFill4 = _bgFillLstIdx['a:solidFill'];

              var _sldTint4 = getColorOpacity(_sldFill4);

              bgcolor = 'background: rgba(' + hexToRgbNew(_phClr) + ',' + _sldTint4 + ');';
            } else if (_bgFillTyp4 === 'GRADIENT_FILL') {
              var _grdFill4 = _bgFillLstIdx['a:gradFill'];
              var _gsLst4 = _grdFill4['a:gsLst']['a:gs']; // get start color
              // let startColorNode
              // let endColorNode

              var _tintArray4 = [];

              for (var _i19 = 0; _i19 < _gsLst4.length; _i19++) {
                var _loTint4 = getTextByPathList(_gsLst4[_i19], ['a:schemeClr', 'a:tint', 'attrs', 'val']);

                _tintArray4[_i19] = _loTint4 !== undefined ? parseInt(_loTint4) / 100000 : 1;
              } // get rot


              var _lin4 = _grdFill4['a:lin'];
              var _rot4 = 90;

              if (_lin4 !== undefined) {
                _rot4 = angleToDegrees(_lin4['attrs']['ang']) + 90;
              }

              bgcolor = 'background: linear-gradient(' + _rot4 + 'deg,';

              for (var _i20 = 0; _i20 < _gsLst4.length; _i20++) {
                if (_i20 === _gsLst4.length - 1) {
                  bgcolor += 'rgba(' + hexToRgbNew(_phClr) + ',' + _tintArray4[_i20] + ')' + ');';
                } else {
                  bgcolor += 'rgba(' + hexToRgbNew(_phClr) + ',' + _tintArray4[_i20] + ')' + ', ';
                }
              }
            } else {// console.log(bgFillTyp) // TODO
            }
          }
        }
      }
    } // console.log("bgcolor: ",bgcolor)


    return bgcolor;
  }

  function hexToRgbNew(hex) {
    var arrBuff = new ArrayBuffer(4);
    var vw = new DataView(arrBuff);
    vw.setUint32(0, parseInt(hex, 16), false);
    var arrByte = new Uint8Array(arrBuff);
    return arrByte[1] + ',' + arrByte[2] + ',' + arrByte[3];
  }

  function getShapeFill(node, isSvgMode, warpObj) {
    // 1. presentationML
    // p:spPr [a:noFill, solidFill, gradFill, blipFill, pattFill, grpFill]
    // From slide
    // Fill Type:
    // console.log("ShapeFill: ", node)
    var fillType = getFillType(getTextByPathList(node, ['p:spPr']));
    var fillColor;

    if (fillType === 'NO_FILL') {
      return isSvgMode ? 'none' : 'background-color: initial;';
    } else if (fillType === 'SOLID_FILL') {
      var shpFill = node['p:spPr']['a:solidFill'];
      fillColor = getSolidFill(shpFill);
    } else if (fillType === 'GRADIENT_FILL') {
      var _shpFill = node['p:spPr']['a:gradFill']; // fillColor = getSolidFill(shpFill);

      fillColor = getGradientFill(_shpFill); // console.log("shpFill",shpFill,grndColor.color)
    } else if (fillType === 'PATTERN_FILL') {
      var _shpFill2 = node['p:spPr']['a:pattFill'];
      fillColor = getPatternFill(_shpFill2);
    } else if (fillType === 'PIC_FILL') {
      var _shpFill3 = node['p:spPr']['a:blipFill'];
      fillColor = getPicFill('slideBg', _shpFill3, warpObj);
    } // 2. drawingML namespace


    if (fillColor === undefined) {
      var clrName = getTextByPathList(node, ['p:style', 'a:fillRef']);
      fillColor = getSolidFill(clrName);
    }

    if (fillColor !== undefined) {
      if (fillType === 'GRADIENT_FILL') {
        if (isSvgMode) {
          // console.log("GRADIENT_FILL color", fillColor.color[0])
          return fillColor;
        } else {
          var colorAry = fillColor.color;
          var rot = fillColor.rot;
          var bgcolor = 'background: linear-gradient(' + rot + 'deg,';

          for (var i = 0; i < colorAry.length; i++) {
            if (i === colorAry.length - 1) {
              bgcolor += colorAry[i] + ');';
            } else {
              bgcolor += colorAry[i] + ', ';
            }
          }

          return bgcolor;
        }
      } else if (fillType === 'PIC_FILL') {
        if (isSvgMode) {
          return fillColor;
        } else {
          return 'background-image:url(' + fillColor + ');';
        }
      } else {
        if (isSvgMode) {
          var color = new Color(fillColor);
          fillColor = color.rgb.toString();
          return fillColor;
        } else {
          // console.log(node,"fillColor: ",fillColor,"fillType: ",fillType,"isSvgMode: ",isSvgMode)
          return 'background-color: #' + fillColor + ';';
        }
      }
    } else {
      if (isSvgMode) {
        return 'none';
      } else {
        return 'background-color: initial;';
      }
    }
  } // /////////////////////Amir//////////////////////////////


  function getFillType(node) {
    // Need to test/////////////////////////////////////////////
    // SOLID_FILL
    // PIC_FILL
    // GRADIENT_FILL
    // PATTERN_FILL
    // NO_FILL
    var fillType = '';

    if (node['a:noFill'] !== undefined) {
      fillType = 'NO_FILL';
    }

    if (node['a:solidFill'] !== undefined) {
      fillType = 'SOLID_FILL';
    }

    if (node['a:gradFill'] !== undefined) {
      fillType = 'GRADIENT_FILL';
    }

    if (node['a:pattFill'] !== undefined) {
      fillType = 'PATTERN_FILL';
    }

    if (node['a:blipFill'] !== undefined) {
      fillType = 'PIC_FILL';
    }

    return fillType;
  }

  function getGradientFill(node) {
    var gsLst = node['a:gsLst']['a:gs']; // get start color

    var colorArray = []; // const tintArray = []

    for (var i = 0; i < gsLst.length; i++) {
      // let loTint
      var loColor = getSolidFill(gsLst[i]);

      if (gsLst[i]['a:srgbClr'] !== undefined) {
        var lumMod = parseInt(getTextByPathList(node, ['a:srgbClr', 'a:lumMod', 'attrs', 'val'])) / 100000;
        var lumOff = parseInt(getTextByPathList(node, ['a:srgbClr', 'a:lumOff', 'attrs', 'val'])) / 100000;

        if (isNaN(lumMod)) {
          lumMod = 1.0;
        }

        if (isNaN(lumOff)) {
          lumOff = 0;
        } // console.log([lumMod, lumOff]);


        loColor = applyLumModify(loColor, lumMod, lumOff);
      } else if (gsLst[i]['a:schemeClr'] !== undefined) {
        // a:schemeClr
        var _lumMod = parseInt(getTextByPathList(gsLst[i], ['a:schemeClr', 'a:lumMod', 'attrs', 'val'])) / 100000;

        var _lumOff = parseInt(getTextByPathList(gsLst[i], ['a:schemeClr', 'a:lumOff', 'attrs', 'val'])) / 100000;

        if (isNaN(_lumMod)) {
          _lumMod = 1.0;
        }

        if (isNaN(_lumOff)) {
          _lumOff = 0;
        } // console.log([lumMod, lumOff]);


        loColor = applyLumModify(loColor, _lumMod, _lumOff);
      } // console.log("loColor",loColor)


      colorArray[i] = loColor;
    } // get rot


    var lin = node['a:lin'];
    var rot = 0;

    if (lin !== undefined) {
      rot = angleToDegrees(lin['attrs']['ang']) + 90;
    }

    return {
      'color': colorArray,
      'rot': rot
    };
  }

  function getPicFill(type, node, warpObj) {
    // Need to test/////////////////////////////////////////////
    // rId
    // TODO - Image Properties - Tile, Stretch, or Display Portion of Image
    // (http://officeopenxml.com/drwPic-tile.php)
    var img;
    var rId = node['a:blip']['attrs']['r:embed'];
    var imgPath;

    if (type === 'slideBg') {
      imgPath = getTextByPathList(warpObj, ['slideResObj', rId, 'target']);
    } else if (type === 'layoutBg') {
      imgPath = getTextByPathList(warpObj, ['layoutResObj', rId, 'target']);
    } else if (type === 'masterBg') {
      imgPath = getTextByPathList(warpObj, ['masterResObj', rId, 'target']);
    }

    if (imgPath === undefined) {
      return undefined;
    }

    var imgExt = imgPath.split('.').pop();

    if (imgExt === 'xml') {
      return undefined;
    }

    var imgArrayBuffer = warpObj['zip'].file(imgPath).asArrayBuffer();
    var imgMimeType = getImageMimeType(imgExt);
    img = 'data:' + imgMimeType + ';base64,' + base64ArrayBuffer(imgArrayBuffer);
    return img;
  }

  function getPatternFill(node) {
    // Need to test/////////////////////////////////////////////
    var bgClr = node['a:bgClr'];
    return getSolidFill(bgClr);
  }

  function getSolidFill(node) {
    if (node === undefined) {
      return undefined;
    }

    var color = 'FFF';

    if (node['a:srgbClr'] !== undefined) {
      color = getTextByPathList(node, ['a:srgbClr', 'attrs', 'val']); // #...
    } else if (node['a:schemeClr'] !== undefined) {
      // a:schemeClr
      var schemeClr = getTextByPathList(node, ['a:schemeClr', 'attrs', 'val']); // console.log(schemeClr)

      color = getSchemeColorFromTheme('a:' + schemeClr, undefined); // #...
    } else if (node['a:scrgbClr'] !== undefined) {
      // <a:scrgbClr r="50%" g="50%" b="50%"/>  //Need to test/////////////////////////////////////////////
      var defBultColorVals = node['a:scrgbClr']['attrs'];
      var red = defBultColorVals['r'].indexOf('%') !== -1 ? defBultColorVals['r'].split('%').shift() : defBultColorVals['r'];
      var green = defBultColorVals['g'].indexOf('%') !== -1 ? defBultColorVals['g'].split('%').shift() : defBultColorVals['g'];
      var blue = defBultColorVals['b'].indexOf('%') !== -1 ? defBultColorVals['b'].split('%').shift() : defBultColorVals['b']; // const scrgbClr = red + ',' + green + ',' + blue

      color = toHex(255 * (Number(red) / 100)) + toHex(255 * (Number(green) / 100)) + toHex(255 * (Number(blue) / 100)); // console.log("scrgbClr: " + scrgbClr);
    } else if (node['a:prstClr'] !== undefined) {
      // <a:prstClr val="black"/>  //Need to test/////////////////////////////////////////////
      var prstClr = node['a:prstClr']['attrs']['val'];
      color = getColorName2Hex(prstClr); // console.log("prstClr: " + prstClr+" => hexClr: "+color);
    } else if (node['a:hslClr'] !== undefined) {
      // <a:hslClr hue="14400000" sat="100%" lum="50%"/>  //Need to test/////////////////////////////////////////////
      var _defBultColorVals = node['a:hslClr']['attrs'];
      var hue = Number(_defBultColorVals['hue']) / 100000;
      var sat = Number(_defBultColorVals['sat'].indexOf('%') !== -1 ? _defBultColorVals['sat'].split('%').shift() : _defBultColorVals['sat']) / 100;
      var lum = Number(_defBultColorVals['lum'].indexOf('%') !== -1 ? _defBultColorVals['lum'].split('%').shift() : _defBultColorVals['lum']) / 100; // const hslClr = defBultColorVals['hue'] + ',' + defBultColorVals['sat'] + ',' + defBultColorVals['lum']

      var hsl2rgb = hslToRgb$$1(hue, sat, lum);
      color = toHex(hsl2rgb.r) + toHex(hsl2rgb.g) + toHex(hsl2rgb.b); // defBultColor = cnvrtHslColor2Hex(hslClr); //TODO
      // console.log("hslClr: " + hslClr);
    } else if (node['a:sysClr'] !== undefined) {
      // <a:sysClr val="windowText" lastClr="000000"/>  //Need to test/////////////////////////////////////////////
      var sysClr = getTextByPathList(node, ['a:sysClr', 'attrs', 'lastClr']);

      if (sysClr !== undefined) {
        color = sysClr;
      }
    }

    return color;
  }

  function toHex(n) {
    var hex = n.toString(16);

    while (hex.length < 2) {
      hex = '0' + hex;
    }

    return hex;
  }

  function hslToRgb$$1(hue, sat, light) {
    var t1, t2, r, g, b;
    hue = hue / 60;

    if (light <= 0.5) {
      t2 = light * (sat + 1);
    } else {
      t2 = light + sat - light * sat;
    }

    t1 = light * 2 - t2;
    r = hueToRgb(t1, t2, hue + 2) * 255;
    g = hueToRgb(t1, t2, hue) * 255;
    b = hueToRgb(t1, t2, hue - 2) * 255;
    return {
      r: r,
      g: g,
      b: b
    };
  }

  function hueToRgb(t1, t2, hue) {
    if (hue < 0) hue += 6;
    if (hue >= 6) hue -= 6;
    if (hue < 1) return (t2 - t1) * hue + t1;else if (hue < 3) return t2;else if (hue < 4) return (t2 - t1) * (4 - hue) + t1;else return t1;
  }

  function getColorName2Hex(name) {
    var hex;
    var colorName = ['AliceBlue', 'AntiqueWhite', 'Aqua', 'Aquamarine', 'Azure', 'Beige', 'Bisque', 'Black', 'BlanchedAlmond', 'Blue', 'BlueViolet', 'Brown', 'BurlyWood', 'CadetBlue', 'Chartreuse', 'Chocolate', 'Coral', 'CornflowerBlue', 'Cornsilk', 'Crimson', 'Cyan', 'DarkBlue', 'DarkCyan', 'DarkGoldenRod', 'DarkGray', 'DarkGrey', 'DarkGreen', 'DarkKhaki', 'DarkMagenta', 'DarkOliveGreen', 'DarkOrange', 'DarkOrchid', 'DarkRed', 'DarkSalmon', 'DarkSeaGreen', 'DarkSlateBlue', 'DarkSlateGray', 'DarkSlateGrey', 'DarkTurquoise', 'DarkViolet', 'DeepPink', 'DeepSkyBlue', 'DimGray', 'DimGrey', 'DodgerBlue', 'FireBrick', 'FloralWhite', 'ForestGreen', 'Fuchsia', 'Gainsboro', 'GhostWhite', 'Gold', 'GoldenRod', 'Gray', 'Grey', 'Green', 'GreenYellow', 'HoneyDew', 'HotPink', 'IndianRed', 'Indigo', 'Ivory', 'Khaki', 'Lavender', 'LavenderBlush', 'LawnGreen', 'LemonChiffon', 'LightBlue', 'LightCoral', 'LightCyan', 'LightGoldenRodYellow', 'LightGray', 'LightGrey', 'LightGreen', 'LightPink', 'LightSalmon', 'LightSeaGreen', 'LightSkyBlue', 'LightSlateGray', 'LightSlateGrey', 'LightSteelBlue', 'LightYellow', 'Lime', 'LimeGreen', 'Linen', 'Magenta', 'Maroon', 'MediumAquaMarine', 'MediumBlue', 'MediumOrchid', 'MediumPurple', 'MediumSeaGreen', 'MediumSlateBlue', 'MediumSpringGreen', 'MediumTurquoise', 'MediumVioletRed', 'MidnightBlue', 'MintCream', 'MistyRose', 'Moccasin', 'NavajoWhite', 'Navy', 'OldLace', 'Olive', 'OliveDrab', 'Orange', 'OrangeRed', 'Orchid', 'PaleGoldenRod', 'PaleGreen', 'PaleTurquoise', 'PaleVioletRed', 'PapayaWhip', 'PeachPuff', 'Peru', 'Pink', 'Plum', 'PowderBlue', 'Purple', 'RebeccaPurple', 'Red', 'RosyBrown', 'RoyalBlue', 'SaddleBrown', 'Salmon', 'SandyBrown', 'SeaGreen', 'SeaShell', 'Sienna', 'Silver', 'SkyBlue', 'SlateBlue', 'SlateGray', 'SlateGrey', 'Snow', 'SpringGreen', 'SteelBlue', 'Tan', 'Teal', 'Thistle', 'Tomato', 'Turquoise', 'Violet', 'Wheat', 'White', 'WhiteSmoke', 'Yellow', 'YellowGreen'];
    var colorHex = ['f0f8ff', 'faebd7', '00ffff', '7fffd4', 'f0ffff', 'f5f5dc', 'ffe4c4', '000000', 'ffebcd', '0000ff', '8a2be2', 'a52a2a', 'deb887', '5f9ea0', '7fff00', 'd2691e', 'ff7f50', '6495ed', 'fff8dc', 'dc143c', '00ffff', '00008b', '008b8b', 'b8860b', 'a9a9a9', 'a9a9a9', '006400', 'bdb76b', '8b008b', '556b2f', 'ff8c00', '9932cc', '8b0000', 'e9967a', '8fbc8f', '483d8b', '2f4f4f', '2f4f4f', '00ced1', '9400d3', 'ff1493', '00bfff', '696969', '696969', '1e90ff', 'b22222', 'fffaf0', '228b22', 'ff00ff', 'dcdcdc', 'f8f8ff', 'ffd700', 'daa520', '808080', '808080', '008000', 'adff2f', 'f0fff0', 'ff69b4', 'cd5c5c', '4b0082', 'fffff0', 'f0e68c', 'e6e6fa', 'fff0f5', '7cfc00', 'fffacd', 'add8e6', 'f08080', 'e0ffff', 'fafad2', 'd3d3d3', 'd3d3d3', '90ee90', 'ffb6c1', 'ffa07a', '20b2aa', '87cefa', '778899', '778899', 'b0c4de', 'ffffe0', '00ff00', '32cd32', 'faf0e6', 'ff00ff', '800000', '66cdaa', '0000cd', 'ba55d3', '9370db', '3cb371', '7b68ee', '00fa9a', '48d1cc', 'c71585', '191970', 'f5fffa', 'ffe4e1', 'ffe4b5', 'ffdead', '000080', 'fdf5e6', '808000', '6b8e23', 'ffa500', 'ff4500', 'da70d6', 'eee8aa', '98fb98', 'afeeee', 'db7093', 'ffefd5', 'ffdab9', 'cd853f', 'ffc0cb', 'dda0dd', 'b0e0e6', '800080', '663399', 'ff0000', 'bc8f8f', '4169e1', '8b4513', 'fa8072', 'f4a460', '2e8b57', 'fff5ee', 'a0522d', 'c0c0c0', '87ceeb', '6a5acd', '708090', '708090', 'fffafa', '00ff7f', '4682b4', 'd2b48c', '008080', 'd8bfd8', 'ff6347', '40e0d0', 'ee82ee', 'f5deb3', 'ffffff', 'f5f5f5', 'ffff00', '9acd32'];
    var findIndx = colorName.indexOf(name);

    if (findIndx !== -1) {
      hex = colorHex[findIndx];
    }

    return hex;
  }

  function getColorOpacity(solidFill) {
    if (solidFill === undefined) {
      return undefined;
    }

    var opcity = 1;

    if (solidFill['a:srgbClr'] !== undefined) {
      var tint = getTextByPathList(solidFill, ['a:srgbClr', 'a:tint', 'attrs', 'val']);

      if (tint !== undefined) {
        opcity = parseInt(tint) / 100000;
      }
    } else if (solidFill['a:schemeClr'] !== undefined) {
      var _tint = getTextByPathList(solidFill, ['a:schemeClr', 'a:tint', 'attrs', 'val']);

      if (_tint !== undefined) {
        opcity = parseInt(_tint) / 100000;
      }
    } else if (solidFill['a:scrgbClr'] !== undefined) {
      var _tint2 = getTextByPathList(solidFill, ['a:scrgbClr', 'a:tint', 'attrs', 'val']);

      if (_tint2 !== undefined) {
        opcity = parseInt(_tint2) / 100000;
      }
    } else if (solidFill['a:prstClr'] !== undefined) {
      var _tint3 = getTextByPathList(solidFill, ['a:prstClr', 'a:tint', 'attrs', 'val']);

      if (_tint3 !== undefined) {
        opcity = parseInt(_tint3) / 100000;
      }
    } else if (solidFill['a:hslClr'] !== undefined) {
      var _tint4 = getTextByPathList(solidFill, ['a:hslClr', 'a:tint', 'attrs', 'val']);

      if (_tint4 !== undefined) {
        opcity = parseInt(_tint4) / 100000;
      }
    } else if (solidFill['a:sysClr'] !== undefined) {
      var _tint5 = getTextByPathList(solidFill, ['a:sysClr', 'a:tint', 'attrs', 'val']);

      if (_tint5 !== undefined) {
        opcity = parseInt(_tint5) / 100000;
      }
    }

    return opcity;
  }

  function getSchemeColorFromTheme(schemeClr, sldMasterNode) {
    // <p:clrMap ...> in slide master
    // e.g. tx2="dk2" bg2="lt2" tx1="dk1" bg1="lt1" slideLayoutClrOvride
    if (slideLayoutClrOvride === '' || slideLayoutClrOvride === undefined) {
      slideLayoutClrOvride = getTextByPathList(sldMasterNode, ['p:sldMaster', 'p:clrMap', 'attrs']);
    } // console.log(slideLayoutClrOvride);


    var schmClrName = schemeClr.substr(2);

    switch (schmClrName) {
      case 'tx1':
      case 'tx2':
      case 'bg1':
      case 'bg2':
        {
          schemeClr = 'a:' + slideLayoutClrOvride[schmClrName]; // console.log(schmClrName+ "=> "+schemeClr);

          break;
        }
    }

    var refNode = getTextByPathList(themeContent, ['a:theme', 'a:themeElements', 'a:clrScheme', schemeClr]);
    var color = getTextByPathList(refNode, ['a:srgbClr', 'attrs', 'val']);

    if (color === undefined) {
      color = getTextByPathList(refNode, ['a:sysClr', 'attrs', 'lastClr']);
    }

    return color;
  }

  function extractChartData(serNode) {
    // console.log('PARSING PPTX CHART:', serNode)
    var dataMat = [];

    if (serNode === undefined) {
      return dataMat;
    }

    if (serNode['c:xVal'] !== undefined) {
      var dataRow = [];
      eachElement(serNode['c:xVal']['c:numRef']['c:numCache']['c:pt'], function (innerNode, index) {
        dataRow.push(parseFloat(innerNode['c:v']));
        return '';
      });
      dataMat.push(dataRow);
      dataRow = [];
      eachElement(serNode['c:yVal']['c:numRef']['c:numCache']['c:pt'], function (innerNode, index) {
        dataRow.push(parseFloat(innerNode['c:v']));
        return '';
      });
      dataMat.push(dataRow);
    } else {
      eachElement(serNode, function (innerNode, index) {
        var dataRow = [];
        var colName = getTextByPathList(innerNode, ['c:tx', 'c:strRef', 'c:strCache', 'c:pt', 'c:v']) || index; // Category (string or number)

        var rowNames = {};

        if (getTextByPathList(innerNode, ['c:cat', 'c:strRef', 'c:strCache', 'c:pt']) !== undefined) {
          eachElement(innerNode['c:cat']['c:strRef']['c:strCache']['c:pt'], function (innerNode, index) {
            rowNames[innerNode['attrs']['idx']] = innerNode['c:v'];
            return '';
          });
        } else if (getTextByPathList(innerNode, ['c:cat', 'c:numRef', 'c:numCache', 'c:pt']) !== undefined) {
          eachElement(innerNode['c:cat']['c:numRef']['c:numCache']['c:pt'], function (innerNode, index) {
            rowNames[innerNode['attrs']['idx']] = innerNode['c:v'];
            return '';
          });
        } // Value


        if (getTextByPathList(innerNode, ['c:val', 'c:numRef', 'c:numCache', 'c:pt']) !== undefined) {
          eachElement(innerNode['c:val']['c:numRef']['c:numCache']['c:pt'], function (innerNode, index) {
            dataRow.push({
              x: innerNode['attrs']['idx'],
              y: parseFloat(innerNode['c:v'])
            });
            return '';
          });
        }

        dataMat.push({
          key: colName,
          values: dataRow,
          xlabels: rowNames
        });
        return '';
      });
    }

    return dataMat;
  } // ===== Node functions =====

  /**
   * getTextByPathStr
   * @param {Object} node
   * @param {string} pathStr
   */


  function getTextByPathStr(node, pathStr) {
    return getTextByPathList(node, pathStr.trim().split(/\s+/));
  }
  /**
   * getTextByPathList
   * @param {Object} node
   * @param {Array.<string>} path
   */


  function getTextByPathList(node, path) {
    if (path.constructor !== Array) {
      throw Error('Error of path type! path is not array.');
    }

    if (node === undefined) {
      return undefined;
    }

    var l = path.length;

    for (var i = 0; i < l; i++) {
      node = node[path[i]];

      if (node === undefined) {
        return undefined;
      }
    }

    return node;
  }
  /**
   * eachElement
   * @param {Object} node
   * @param {function} doFunction
   */


  function eachElement(node, doFunction) {
    if (node === undefined) {
      return;
    }

    var result = '';

    if (node.constructor === Array) {
      var l = node.length;

      for (var i = 0; i < l; i++) {
        result += doFunction(node[i], i);
      }
    } else {
      result += doFunction(node, 0);
    }

    return result;
  }
  /*
  // ===== Color functions =====
  /!**
  * applyShade
  * @param {string} rgbStr
  * @param {number} shadeValue
  *!/
  function applyShade (rgbStr, shadeValue) {
  const color = new colz.Color(rgbStr)
  color.setLum(color.hsl.l * shadeValue)
  return color.rgb.toString()
  }
  /!**
  * applyTint
  * @param {string} rgbStr
  * @param {number} tintValue
  *!/
  function applyTint (rgbStr, tintValue) {
  const color = new colz.Color(rgbStr)
  color.setLum(color.hsl.l * tintValue + (1 - tintValue))
  return color.rgb.toString()
  }
  */

  /**
   * applyLumModify
   * @param {string} rgbStr
   * @param {number} factor
   * @param {number} offset
   */


  function applyLumModify(rgbStr, factor, offset) {
    var color = new Color(rgbStr); // color.setLum(color.hsl.l * factor);

    color.setLum(color.hsl.l * (1 + offset));
    return color.rgb.toString();
  } // /////////////////////Amir////////////////


  function angleToDegrees(angle) {
    if (angle === '' || angle == null) {
      return 0;
    }

    return Math.round(angle / 60000);
  }

  function getImageMimeType(imgFileExt) {
    var mimeType = ''; // console.log(imgFileExt)

    switch (imgFileExt.toLowerCase()) {
      case 'jpg':
      case 'jpeg':
        {
          mimeType = 'image/jpeg';
          break;
        }

      case 'png':
        {
          mimeType = 'image/png';
          break;
        }

      case 'gif':
        {
          mimeType = 'image/gif';
          break;
        }

      case 'emf':
        {
          // Not native support
          mimeType = 'image/x-emf';
          break;
        }

      case 'wmf':
        {
          // Not native support
          mimeType = 'image/x-wmf';
          break;
        }

      case 'svg':
        {
          mimeType = 'image/svg+xml';
          break;
        }

      default:
        {
          mimeType = 'image/*';
        }
    }

    return mimeType;
  }

  function getSvgGradient(w, h, angl, colorArray, shpId) {
    var stopsArray = getMiddleStops(colorArray.length - 2);
    var xyArray = SVGangle(angl, h, w);
    var x1 = xyArray[0];
    var y1 = xyArray[1];
    var x2 = xyArray[2];
    var y2 = xyArray[3];
    var sal = stopsArray.length;
    var sr = sal < 20 ? 100 : 1000;
    var svgAngle = ' gradientUnits="userSpaceOnUse" x1="' + x1 + '%" y1="' + y1 + '%" x2="' + x2 + '%" y2="' + y2 + '%"';
    var svg = '<linearGradient id="linGrd_' + shpId + '"' + svgAngle + '>\n';

    for (var i = 0; i < sal; i++) {
      svg += '<stop offset="' + Math.round(parseFloat(stopsArray[i]) / 100 * sr) / sr + '" stop-color="' + colorArray[i] + '"';
      svg += '/>\n';
    }

    svg += '</linearGradient>\n' + '';
    return svg;
  }

  function getMiddleStops(s) {
    var sArry = ['0%', '100%'];

    if (s === 0) {
      return true;
    } else {
      var i = s;

      while (i--) {
        var middleStop = 100 - 100 / (s + 1) * (i + 1); // AM: Ex - For 3 middle stops, progression will be 25%, 50%, and 75%, plus 0% and 100% at the ends.

        var middleStopString = middleStop + '%';
        sArry.splice(-1, 0, middleStopString);
      } // AM: add into stopsArray before 100%

    }

    return sArry;
  }

  function SVGangle(deg, svgHeight, svgWidth) {
    var w = parseFloat(svgWidth);
    var h = parseFloat(svgHeight);
    var ang = parseFloat(deg);
    var o = 2;
    var n = 2;
    var wc = w / 2;
    var hc = h / 2;
    var tx1 = 2;
    var ty1 = 2;
    var tx2 = 2;
    var ty2 = 2;
    var k = (ang % 360 + 360) % 360;
    var j = (360 - k) * Math.PI / 180;
    var i = Math.tan(j);
    var l = hc - i * wc;

    if (k === 0) {
      tx1 = w;
      ty1 = hc;
      tx2 = 0;
      ty2 = hc;
    } else if (k < 90) {
      n = w;
      o = 0;
    } else if (k === 90) {
      tx1 = wc;
      ty1 = 0;
      tx2 = wc;
      ty2 = h;
    } else if (k < 180) {
      n = 0;
      o = 0;
    } else if (k === 180) {
      tx1 = 0;
      ty1 = hc;
      tx2 = w;
      ty2 = hc;
    } else if (k < 270) {
      n = 0;
      o = h;
    } else if (k === 270) {
      tx1 = wc;
      ty1 = h;
      tx2 = wc;
      ty2 = 0;
    } else {
      n = w;
      o = h;
    } // AM: I could not quite figure out what m, n, and o are supposed to represent from the original code on visualcsstools.com.


    var m = o + n / i;
    tx1 = tx1 === 2 ? i * (m - l) / (Math.pow(i, 2) + 1) : tx1;
    ty1 = ty1 === 2 ? i * tx1 + l : ty1;
    tx2 = tx2 === 2 ? w - tx1 : tx2;
    ty2 = ty2 === 2 ? h - ty1 : ty2;
    var x1 = Math.round(tx2 / w * 100 * 100) / 100;
    var y1 = Math.round(ty2 / h * 100 * 100) / 100;
    var x2 = Math.round(tx1 / w * 100 * 100) / 100;
    var y2 = Math.round(ty1 / h * 100 * 100) / 100;
    return [x1, y1, x2, y2];
  }

  function getSvgImagePattern(fillColor, shpId) {
    var ptrn = '<pattern id="imgPtrn_' + shpId + '"  patternContentUnits="objectBoundingBox"  width="1" height="1">';
    ptrn += '<image  xlink:href="' + fillColor + '" preserveAspectRatio="none" width="1" height="1"></image>';
    ptrn += '</pattern>';
    return ptrn;
  }
}

var pptxStyle = "section {\n  width: 100%;\n  height: 690px;\n  position: relative;\n  border: 1px solid #333;\n  background-color: #EFEFEF;\n  text-align: center;\n  border-radius: 10px;\n  box-shadow: 1px 1px 3px #AAA;\n  overflow: hidden;\n}\n\nsection div.block {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n}\n\nsection div.content {\n  display: flex;\n  flex-direction: column;\n  /*\n  justify-content: center;\n  align-items: flex-end;\n  */\n}\n\nsection div.v-up {\n  justify-content: flex-start;\n}\nsection div.v-mid {\n  justify-content: center;\n}\nsection div.v-down {\n  justify-content: flex-end;\n}\nsection div.h-left {\n  align-items: flex-start;\n  text-align: left;\n}\nsection div.h-mid {\n  align-items: center;\n  text-align: center;\n}\nsection div.h-right {\n  align-items: flex-end;\n  text-align: right;\n}\nsection div.up-left {\n  justify-content: flex-start;\n  align-items: flex-start;\n  text-align: left;\n}\nsection div.up-center {\n  justify-content: flex-start;\n  align-items: center;\n}\nsection div.up-right {\n  justify-content: flex-start;\n  align-items: flex-end;\n}\nsection div.center-left {\n  justify-content: center;\n  align-items: flex-start;\n  text-align: left;\n}\nsection div.center-center {\n  justify-content: center;\n  align-items: center;\n}\nsection div.center-right {\n  justify-content: center;\n  align-items: flex-end;\n}\nsection div.down-left {\n  justify-content: flex-end;\n  align-items: flex-start;\n  text-align: left;\n}\nsection div.down-center {\n  justify-content: flex-end;\n  align-items: center;\n}\nsection div.down-right {\n  justify-content: flex-end;\n  align-items: flex-end;\n}\n\nsection span.text-block {\n  /* display: inline-block; */\n}\n\nli.slide {\n  margin: 10px 0;\n  font-size: 18px;\n}\n\ndiv.footer {\n  text-align: center;\n}\n\nsection table {\n  position: absolute;\n}\n\nsection table, section th, section td {\n  border: 1px solid black;\n}\n\nsection svg.drawing {\n  position: absolute;\n  overflow: visible;\n}";

/* global $, dimple */
'use strict';

/**
 * @param {ArrayBuffer} pptx
 * @param {Element|String} resultElement
 * @param {Element|String} [thumbElement]
 */

var renderPptx = function renderPptx(pptx, resultElement, thumbElement) {
  var $result = $(resultElement);
  var $wrapper = $('<div class="pptx-wrapper"></div>');
  $result.html('');
  $result.append($wrapper);
  $wrapper.append("<style>".concat(pptxStyle, "</style>"));
  var isDone = false;
  return new Promise(function (resolve, reject) {
    var processMessage = function processMessage(msg) {
      if (isDone) return;

      switch (msg.type) {
        case 'slide':
          $wrapper.append(msg.data);
          break;

        case 'pptx-thumb':
          if (thumbElement) $(thumbElement).attr('src', "data:image/jpeg;base64,".concat(msg.data));
          break;

        case 'slideSize':
          break;

        case 'globalCSS':
          $wrapper.append("<style>".concat(msg.data, "</style>"));
          break;

        case 'Done':
          isDone = true;
          processCharts(msg.data.charts);
          resolve(msg.data.time);
          break;

        case 'WARN':
          console.warn('PPTX processing warning: ', msg.data);
          break;

        case 'ERROR':
          isDone = true;
          console.error('PPTX processing error: ', msg.data);
          reject(new Error(msg.data));
          break;

        case 'DEBUG':
          // console.debug('Worker: ', msg.data);
          break;

        case 'INFO':
        default: // console.info('Worker: ', msg.data);

      }
    };
    /*
    // Actual Web Worker - If you want to use this, switching worker's url to Blob is probably better
    const worker = new Worker('./dist/worker.js')
    worker.addEventListener('message', event => processMessage(event.data), false)
    const stopWorker = setInterval(() => { // Maybe this should be done in the message processing
      if (isDone) {
        worker.terminate()
        // console.log("worker terminated");
        clearInterval(stopWorker)
      }
    }, 500)
    */


    var worker = {
      // shim worker
      postMessage: function postMessage() {},
      terminate: function terminate() {}
    };
    processPptx(function (func) {
      worker.postMessage = func;
    }, processMessage);
    worker.postMessage({
      'type': 'processPPTX',
      'data': pptx
    });
  }).then(function (time) {
    var resize = function resize() {
      var slidesWidth = Math.max.apply(Math, _toConsumableArray(Array.from($wrapper.children('section')).map(function (s) {
        return s.offsetWidth;
      })));
      var wrapperWidth = $wrapper[0].offsetWidth;
      $wrapper.css({
        'transform': "scale(".concat(wrapperWidth / slidesWidth, ")"),
        'transform-origin': 'top left'
      });
    };

    resize();
    window.addEventListener('resize', resize);
    setNumericBullets($('.block'));
    setNumericBullets($('table td'));
    return time;
  });
};

function processCharts(queue) {
  for (var i = 0; i < queue.length; i++) {
    processSingleChart(queue[i].data);
  }
}

function convertChartData(chartData) {
  var data = [];
  var xLabels = [];
  var groupLabels = [];
  chartData.forEach(function (group, i) {
    var groupName = group.key;
    groupLabels[i] = group.key;
    group.values.forEach(function (value, j) {
      var labelName = group.xlabels[j];
      xLabels[j] = group.xlabels[j];
      data.push({
        name: labelName,
        group: groupName,
        value: value.y
      });
    });
  }); // console.log('TRANSFORMED DATA:', (data))

  return {
    data: data,
    xLabels: xLabels,
    groupLabels: groupLabels
  };
}

function processSingleChart(d) {
  var chartID = d.chartID;
  var chartType = d.chartType;
  var chartData = d.chartData; // console.log(`WRITING GRAPH OF TYPE ${chartType} TO ID #${chartID}:`, chartData)

  var data = [];

  switch (chartType) {
    case 'lineChart':
      {
        var _convertChartData = convertChartData(chartData),
            data_ = _convertChartData.data,
            xLabels = _convertChartData.xLabels,
            groupLabels = _convertChartData.groupLabels;

        data = data_;
        var container = document.getElementById(chartID);
        var svg = dimple.newSvg("#".concat(chartID), container.style.width, container.style.height); // eslint-disable-next-line new-cap

        var myChart = new dimple.chart(svg, data);
        var xAxis = myChart.addCategoryAxis('x', 'name');
        xAxis.addOrderRule(xLabels);
        xAxis.addGroupOrderRule(groupLabels);
        xAxis.title = null;
        var yAxis = myChart.addMeasureAxis('y', 'value');
        yAxis.title = null;
        myChart.addSeries('group', dimple.plot.line);
        myChart.addLegend(60, 10, 500, 20, 'right');
        myChart.draw();
        break;
      }

    case 'barChart':
      {
        var _convertChartData2 = convertChartData(chartData),
            _data_ = _convertChartData2.data,
            _xLabels = _convertChartData2.xLabels,
            _groupLabels = _convertChartData2.groupLabels;

        data = _data_;

        var _container = document.getElementById(chartID);

        var _svg = dimple.newSvg('#' + chartID, _container.style.width, _container.style.height); // eslint-disable-next-line new-cap


        var _myChart = new dimple.chart(_svg, data);

        var _xAxis = _myChart.addCategoryAxis('x', ['name', 'group']);

        _xAxis.addOrderRule(_xLabels);

        _xAxis.addGroupOrderRule(_groupLabels);

        _xAxis.title = null;

        var _yAxis = _myChart.addMeasureAxis('y', 'value');

        _yAxis.title = null;

        _myChart.addSeries('group', dimple.plot.bar);

        _myChart.addLegend(60, 10, 500, 20, 'right');

        _myChart.draw();

        break;
      }

    case 'pieChart':
    case 'pie3DChart':
      {
        // data = chartData[0].values
        // chart = nv.models.pieChart()
        // nvDraw(chart, data)
        var _convertChartData3 = convertChartData(chartData),
            _data_2 = _convertChartData3.data,
            _groupLabels2 = _convertChartData3.groupLabels;

        data = _data_2;

        var _container2 = document.getElementById(chartID);

        var _svg2 = dimple.newSvg("#".concat(chartID), _container2.style.width, _container2.style.height); // eslint-disable-next-line new-cap


        var _myChart2 = new dimple.chart(_svg2, data);

        var pieAxis = _myChart2.addMeasureAxis('p', 'value');

        pieAxis.addOrderRule(_groupLabels2);

        _myChart2.addSeries('name', dimple.plot.pie);

        _myChart2.addLegend(50, 20, 400, 300, 'left');

        _myChart2.draw();

        break;
      }

    case 'areaChart':
      {
        var _convertChartData4 = convertChartData(chartData),
            _data_3 = _convertChartData4.data,
            _xLabels2 = _convertChartData4.xLabels,
            _groupLabels3 = _convertChartData4.groupLabels;

        data = _data_3;

        var _container3 = document.getElementById(chartID);

        var _svg3 = dimple.newSvg('#' + chartID, _container3.style.width, _container3.style.height); // eslint-disable-next-line new-cap


        var _myChart3 = new dimple.chart(_svg3, data);

        var _xAxis2 = _myChart3.addCategoryAxis('x', 'name');

        _xAxis2.addOrderRule(_xLabels2);

        _xAxis2.addGroupOrderRule(_groupLabels3);

        _xAxis2.title = null;

        var _yAxis2 = _myChart3.addMeasureAxis('y', 'value');

        _yAxis2.title = null;

        _myChart3.addSeries('group', dimple.plot.area);

        _myChart3.addLegend(60, 10, 500, 20, 'right');

        _myChart3.draw();

        break;
      }

    case 'scatterChart':
      {
        for (var i = 0; i < chartData.length; i++) {
          var arr = [];

          for (var j = 0; j < chartData[i].length; j++) {
            arr.push({
              x: j,
              y: chartData[i][j]
            });
          }

          data.push({
            key: 'data' + (i + 1),
            values: arr
          });
        } // data = chartData;
        // chart = nv.models.scatterChart()
        //   .showDistX(true)
        //   .showDistY(true)
        //   .color(d3.scale.category10().range())
        // chart.xAxis.axisLabel('X').tickFormat(d3.format('.02f'))
        // chart.yAxis.axisLabel('Y').tickFormat(d3.format('.02f'))
        // nvDraw(chart, data)


        break;
      }

    default:
  }
}

function setNumericBullets(elem) {
  var paragraphsArray = elem;

  for (var i = 0; i < paragraphsArray.length; i++) {
    var buSpan = $(paragraphsArray[i]).find('.numeric-bullet-style');

    if (buSpan.length > 0) {
      // console.log("DIV-"+i+":");
      var prevBultTyp = '';
      var prevBultLvl = '';
      var buletIndex = 0;
      var tmpArry = [];
      var tmpArryIndx = 0;
      var buletTypSrry = [];

      for (var j = 0; j < buSpan.length; j++) {
        var bulletType = $(buSpan[j]).data('bulltname');
        var bulletLvl = $(buSpan[j]).data('bulltlvl'); // console.log(j+" - "+bult_typ+" lvl: "+bult_lvl );

        if (buletIndex === 0) {
          prevBultTyp = bulletType;
          prevBultLvl = bulletLvl;
          tmpArry[tmpArryIndx] = buletIndex;
          buletTypSrry[tmpArryIndx] = bulletType;
          buletIndex++;
        } else {
          if (bulletType === prevBultTyp && bulletLvl === prevBultLvl) {
            prevBultTyp = bulletType;
            prevBultLvl = bulletLvl;
            buletIndex++;
            tmpArry[tmpArryIndx] = buletIndex;
            buletTypSrry[tmpArryIndx] = bulletType;
          } else if (bulletType !== prevBultTyp && bulletLvl === prevBultLvl) {
            prevBultTyp = bulletType;
            prevBultLvl = bulletLvl;
            tmpArryIndx++;
            tmpArry[tmpArryIndx] = buletIndex;
            buletTypSrry[tmpArryIndx] = bulletType;
            buletIndex = 1;
          } else if (bulletType !== prevBultTyp && Number(bulletLvl) > Number(prevBultLvl)) {
            prevBultTyp = bulletType;
            prevBultLvl = bulletLvl;
            tmpArryIndx++;
            tmpArry[tmpArryIndx] = buletIndex;
            buletTypSrry[tmpArryIndx] = bulletType;
            buletIndex = 1;
          } else if (bulletType !== prevBultTyp && Number(bulletLvl) < Number(prevBultLvl)) {
            prevBultTyp = bulletType;
            prevBultLvl = bulletLvl;
            tmpArryIndx--;
            buletIndex = tmpArry[tmpArryIndx] + 1;
          }
        } // console.log(buletTypSrry[tmpArryIndx]+" - "+buletIndex);


        var numIdx = getNumTypeNum(buletTypSrry[tmpArryIndx], buletIndex);
        $(buSpan[j]).html(numIdx);
      }
    }
  }
}

function getNumTypeNum(numTyp, num) {
  var rtrnNum = '';

  switch (numTyp) {
    case 'arabicPeriod':
      rtrnNum = num + '. ';
      break;

    case 'arabicParenR':
      rtrnNum = num + ') ';
      break;

    case 'alphaLcParenR':
      rtrnNum = alphaNumeric(num, 'lowerCase') + ') ';
      break;

    case 'alphaLcPeriod':
      rtrnNum = alphaNumeric(num, 'lowerCase') + '. ';
      break;

    case 'alphaUcParenR':
      rtrnNum = alphaNumeric(num, 'upperCase') + ') ';
      break;

    case 'alphaUcPeriod':
      rtrnNum = alphaNumeric(num, 'upperCase') + '. ';
      break;

    case 'romanUcPeriod':
      rtrnNum = romanize(num) + '. ';
      break;

    case 'romanLcParenR':
      rtrnNum = romanize(num) + ') ';
      break;

    case 'hebrew2Minus':
      rtrnNum = hebrew2Minus.format(num) + '-';
      break;

    default:
      rtrnNum = num;
  }

  return rtrnNum;
}

function romanize(num) {
  if (!+num) return false;
  var digits = String(+num).split('');
  var key = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM', '', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC', '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'];
  var roman = '';
  var i = 3;

  while (i--) {
    roman = (key[+digits.pop() + i * 10] || '') + roman;
  }

  return new Array(+digits.join('') + 1).join('M') + roman;
}

var hebrew2Minus = archaicNumbers([[1000, ''], [400, 'ת'], [300, 'ש'], [200, 'ר'], [100, 'ק'], [90, 'צ'], [80, 'פ'], [70, 'ע'], [60, 'ס'], [50, 'נ'], [40, 'מ'], [30, 'ל'], [20, 'כ'], [10, 'י'], [9, 'ט'], [8, 'ח'], [7, 'ז'], [6, 'ו'], [5, 'ה'], [4, 'ד'], [3, 'ג'], [2, 'ב'], [1, 'א'], [/יה/, 'ט״ו'], [/יו/, 'ט״ז'], [/([א-ת])([א-ת])$/, '$1״$2'], [/^([א-ת])$/, '$1׳']]);

function archaicNumbers(arr) {
  // const arrParse = arr.slice().sort(function (a, b) { return b[1].length - a[1].length })
  return {
    format: function format(n) {
      var ret = '';
      $.each(arr, function () {
        var num = this[0];

        if (parseInt(num) > 0) {
          for (; n >= num; n -= num) {
            ret += this[1];
          }
        } else {
          ret = ret.replace(num, this[1]);
        }
      });
      return ret;
    }
  };
}

function alphaNumeric(num, upperLower) {
  num = Number(num) - 1;
  var aNum = '';

  if (upperLower === 'upperCase') {
    aNum = ((num / 26 >= 1 ? String.fromCharCode(num / 26 + 64) : '') + String.fromCharCode(num % 26 + 65)).toUpperCase();
  } else if (upperLower === 'lowerCase') {
    aNum = ((num / 26 >= 1 ? String.fromCharCode(num / 26 + 64) : '') + String.fromCharCode(num % 26 + 65)).toLowerCase();
  }

  return aNum;
}

return renderPptx;

}());
//# sourceMappingURL=pptx2html.js.map
